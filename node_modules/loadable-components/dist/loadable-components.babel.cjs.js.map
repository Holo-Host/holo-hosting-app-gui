{"version":3,"file":"loadable-components.babel.cjs.js","sources":["../src/babel.js"],"sourcesContent":["import syntax from 'babel-plugin-syntax-dynamic-import'\n\nexport default function({ types: t }) {\n  return {\n    inherits: syntax,\n\n    visitor: {\n      ImportDeclaration(path) {\n        const source = path.node.source.value\n        if (source !== 'loadable-components') return\n\n        const defaultSpecifier = path\n          .get('specifiers')\n          .find(specifier => specifier.isImportDefaultSpecifier())\n\n        if (!defaultSpecifier) return\n\n        const bindingName = defaultSpecifier.node.local.name\n        const binding = path.scope.getBinding(bindingName)\n\n        binding.referencePaths.forEach(refPath => {\n          let callExpression = refPath.parentPath\n\n          if (\n            callExpression.isMemberExpression() &&\n            callExpression.node.computed === false &&\n            callExpression.get('property').isIdentifier({ name: 'Map' })\n          ) {\n            callExpression = callExpression.parentPath\n          }\n\n          if (!callExpression.isCallExpression()) return\n\n          const args = callExpression.get('arguments')\n          const loaderMethod = args[0]\n\n          if (!loaderMethod) return\n\n          const dynamicImports = []\n\n          loaderMethod.traverse({\n            Import({ parentPath }) {\n              dynamicImports.push(parentPath)\n            },\n          })\n\n          if (!dynamicImports.length) return\n\n          let options = args[1]\n          if (args[1]) {\n            options = options.node\n          } else {\n            options = t.objectExpression([])\n            callExpression.node.arguments.push(options)\n          }\n\n          options.properties.push(\n            t.objectProperty(\n              t.identifier('modules'),\n              t.arrayExpression(\n                dynamicImports.map(\n                  dynamicImport => dynamicImport.get('arguments')[0].node,\n                ),\n              ),\n            ),\n          )\n        })\n      },\n    },\n  }\n}\n"],"names":["t","types","syntax","path","source","node","value","defaultSpecifier","get","find","specifier","isImportDefaultSpecifier","bindingName","local","name","binding","scope","getBinding","referencePaths","forEach","callExpression","refPath","parentPath","isMemberExpression","computed","isIdentifier","isCallExpression","args","loaderMethod","dynamicImports","traverse","push","length","options","objectExpression","arguments","properties","objectProperty","identifier","arrayExpression","map","dynamicImport"],"mappings":";;;;;;;;AAEe,sBAAuB;MAALA,CAAK,QAAZC,KAAY;;SAC7B;cACKC,MADL;;aAGI;uBAAA,6BACWC,IADX,EACiB;YAChBC,SAASD,KAAKE,IAAL,CAAUD,MAAV,CAAiBE,KAAhC;YACIF,WAAW,qBAAf,EAAsC;;YAEhCG,mBAAmBJ,KACtBK,GADsB,CAClB,YADkB,EAEtBC,IAFsB,CAEjB;iBAAaC,UAAUC,wBAAV,EAAb;SAFiB,CAAzB;;YAII,CAACJ,gBAAL,EAAuB;;YAEjBK,cAAcL,iBAAiBF,IAAjB,CAAsBQ,KAAtB,CAA4BC,IAAhD;YACMC,UAAUZ,KAAKa,KAAL,CAAWC,UAAX,CAAsBL,WAAtB,CAAhB;;gBAEQM,cAAR,CAAuBC,OAAvB,CAA+B,mBAAW;cACpCC,iBAAiBC,QAAQC,UAA7B;;cAGEF,eAAeG,kBAAf,MACAH,eAAef,IAAf,CAAoBmB,QAApB,KAAiC,KADjC,IAEAJ,eAAeZ,GAAf,CAAmB,UAAnB,EAA+BiB,YAA/B,CAA4C,EAAEX,MAAM,KAAR,EAA5C,CAHF,EAIE;6BACiBM,eAAeE,UAAhC;;;cAGE,CAACF,eAAeM,gBAAf,EAAL,EAAwC;;cAElCC,OAAOP,eAAeZ,GAAf,CAAmB,WAAnB,CAAb;cACMoB,eAAeD,KAAK,CAAL,CAArB;;cAEI,CAACC,YAAL,EAAmB;;cAEbC,iBAAiB,EAAvB;;uBAEaC,QAAb,CAAsB;kBAAA,yBACG;kBAAdR,UAAc,SAAdA,UAAc;;6BACNS,IAAf,CAAoBT,UAApB;;WAFJ;;cAMI,CAACO,eAAeG,MAApB,EAA4B;;cAExBC,UAAUN,KAAK,CAAL,CAAd;cACIA,KAAK,CAAL,CAAJ,EAAa;sBACDM,QAAQ5B,IAAlB;WADF,MAEO;sBACKL,EAAEkC,gBAAF,CAAmB,EAAnB,CAAV;2BACe7B,IAAf,CAAoB8B,SAApB,CAA8BJ,IAA9B,CAAmCE,OAAnC;;;kBAGMG,UAAR,CAAmBL,IAAnB,CACE/B,EAAEqC,cAAF,CACErC,EAAEsC,UAAF,CAAa,SAAb,CADF,EAEEtC,EAAEuC,eAAF,CACEV,eAAeW,GAAf,CACE;mBAAiBC,cAAcjC,GAAd,CAAkB,WAAlB,EAA+B,CAA/B,EAAkCH,IAAnD;WADF,CADF,CAFF,CADF;SApCF;;;GAjBN;;;;;"}