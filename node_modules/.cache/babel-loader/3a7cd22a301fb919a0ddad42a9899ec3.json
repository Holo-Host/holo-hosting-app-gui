{"ast":null,"code":"'use strict';\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar compileRoute = require('./compile-route');\n\nvar FetchMock = {};\n\nFetchMock.mock = function (matcher, response) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var route = void 0; // Handle the variety of parameters accepted by mock (see README)\n\n  if (matcher && response) {\n    route = (0, _assign2.default)({\n      matcher: matcher,\n      response: response\n    }, options);\n  } else if (matcher && matcher.matcher) {\n    route = matcher;\n  } else {\n    throw new Error('Invalid parameters passed to fetch-mock');\n  }\n\n  this.addRoute(route);\n  return this._mock();\n};\n\nvar getMatcher = function getMatcher(route, propName) {\n  return function (route2) {\n    return route[propName] === route2[propName];\n  };\n};\n\nFetchMock.addRoute = function (uncompiledRoute) {\n  var route = this.compileRoute(uncompiledRoute);\n  var clashes = this.routes.filter(getMatcher(route, 'name'));\n  var overwriteRoutes = 'overwriteRoutes' in route ? route.overwriteRoutes : this.config.overwriteRoutes;\n\n  if (overwriteRoutes === false || !clashes.length) {\n    this._uncompiledRoutes.push(uncompiledRoute);\n\n    return this.routes.push(route);\n  }\n\n  var methodsMatch = getMatcher(route, 'method');\n\n  if (overwriteRoutes === true) {\n    var index = this.routes.indexOf(clashes.find(methodsMatch));\n\n    this._uncompiledRoutes.splice(index, 1, uncompiledRoute);\n\n    return this.routes.splice(index, 1, route);\n  }\n\n  if (clashes.some(function (existingRoute) {\n    return !route.method || methodsMatch(existingRoute);\n  })) {\n    throw new Error('Adding route with same name as existing route. See `overwriteRoutes` option.');\n  }\n\n  this._uncompiledRoutes.push(uncompiledRoute);\n\n  this.routes.push(route);\n};\n\nFetchMock._mock = function () {\n  if (!this.isSandbox) {\n    // Do this here rather than in the constructor to ensure it's scoped to the test\n    this.realFetch = this.realFetch || this.global.fetch;\n    this.global.fetch = this.fetchHandler;\n  }\n\n  return this;\n};\n\nFetchMock.catch = function (response) {\n  if (this.fallbackResponse) {\n    console.warn('calling fetchMock.catch() twice - are you sure you want to overwrite the previous fallback response'); // eslint-disable-line\n  }\n\n  this.fallbackResponse = response || 'ok';\n  return this._mock();\n};\n\nFetchMock.spy = function () {\n  this._mock();\n\n  return this.catch(this.getNativeFetch());\n};\n\nFetchMock.compileRoute = compileRoute;\n\nFetchMock.once = function (matcher, response) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return this.mock(matcher, response, (0, _assign2.default)({}, options, {\n    repeat: 1\n  }));\n};\n\n['get', 'post', 'put', 'delete', 'head', 'patch'].forEach(function (method) {\n  FetchMock[method] = function (matcher, response) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this.mock(matcher, response, (0, _assign2.default)({}, options, {\n      method: method.toUpperCase()\n    }));\n  };\n\n  FetchMock[method + 'Once'] = function (matcher, response) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this.once(matcher, response, (0, _assign2.default)({}, options, {\n      method: method.toUpperCase()\n    }));\n  };\n});\n\nFetchMock.restore = function () {\n  if (this.realFetch) {\n    this.global.fetch = this.realFetch;\n    this.realFetch = undefined;\n  }\n\n  this.fallbackResponse = undefined;\n  this.routes = [];\n  this._uncompiledRoutes = [];\n  this.reset();\n  return this;\n};\n\nFetchMock.reset = function () {\n  this._calls = {};\n  this._allCalls = [];\n  this._holdingPromises = [];\n  this.routes.forEach(function (route) {\n    return route.reset && route.reset();\n  });\n  return this;\n};\n\nmodule.exports = FetchMock;","map":null,"metadata":{},"sourceType":"script"}