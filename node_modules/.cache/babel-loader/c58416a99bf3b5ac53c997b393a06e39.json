{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { Component } from 'react';\nimport { connect } from 'react-redux';\nimport isEqual from 'lodash/isEqual';\nimport { crudGetManyReference as crudGetManyReferenceAction } from '../../actions';\nimport { SORT_ASC, SORT_DESC } from '../../reducer/admin/resource/list/queryReducer';\nimport { getIds, getReferences, getTotal, nameRelatedTo } from '../../reducer/admin/references/oneToMany';\n/**\n * Render related records to the current one.\n *\n * You must define the fields to be passed to the iterator component as children.\n *\n * @example Display all the comments of the current post as a datagrid\n * <ReferenceManyField reference=\"comments\" target=\"post_id\">\n *     <Datagrid>\n *         <TextField source=\"id\" />\n *         <TextField source=\"body\" />\n *         <DateField source=\"created_at\" />\n *         <EditButton />\n *     </Datagrid>\n * </ReferenceManyField>\n *\n * @example Display all the books by the current author, only the title\n * <ReferenceManyField reference=\"books\" target=\"author_id\">\n *     <SingleFieldList>\n *         <ChipField source=\"title\" />\n *     </SingleFieldList>\n * </ReferenceManyField>\n *\n * By default, restricts the possible values to 25. You can extend this limit\n * by setting the `perPage` prop.\n *\n * @example\n * <ReferenceManyField perPage={10} reference=\"comments\" target=\"post_id\">\n *    ...\n * </ReferenceManyField>\n *\n * By default, orders the possible values by id desc. You can change this order\n * by setting the `sort` prop (an object with `field` and `order` properties).\n *\n * @example\n * <ReferenceManyField sort={{ field: 'created_at', order: 'DESC' }} reference=\"comments\" target=\"post_id\">\n *    ...\n * </ReferenceManyField>\n *\n * Also, you can filter the query used to populate the possible values. Use the\n * `filter` prop for that.\n *\n * @example\n * <ReferenceManyField filter={{ is_published: true }} reference=\"comments\" target=\"post_id\">\n *    ...\n * </ReferenceManyField>\n */\n\nvar UnconnectedReferenceManyFieldController =\n/** @class */\nfunction (_super) {\n  __extends(UnconnectedReferenceManyFieldController, _super);\n\n  function UnconnectedReferenceManyFieldController() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      sort: _this.props.sort,\n      page: 1,\n      perPage: _this.props.perPage\n    };\n\n    _this.setSort = function (field) {\n      var order = _this.state.sort.field === field && _this.state.sort.order === SORT_ASC ? SORT_DESC : SORT_ASC;\n\n      _this.setState({\n        sort: {\n          field: field,\n          order: order\n        }\n      }, _this.fetchReferences);\n    };\n\n    _this.setPage = function (page) {\n      return _this.setState({\n        page: page\n      }, _this.fetchReferences);\n    };\n\n    _this.setPerPage = function (perPage) {\n      return _this.setState({\n        perPage: perPage\n      }, _this.fetchReferences);\n    };\n\n    return _this;\n  }\n\n  UnconnectedReferenceManyFieldController.prototype.componentDidMount = function () {\n    this.fetchReferences();\n  };\n\n  UnconnectedReferenceManyFieldController.prototype.componentWillReceiveProps = function (nextProps) {\n    if (this.props.record.id !== nextProps.record.id || !isEqual(this.props.filter, nextProps.filter)) {\n      this.fetchReferences(nextProps);\n    }\n\n    if (!isEqual(this.props.sort, nextProps.sort)) {\n      this.setState({\n        sort: nextProps.sort\n      }, this.fetchReferences);\n    }\n  };\n\n  UnconnectedReferenceManyFieldController.prototype.fetchReferences = function (_a) {\n    var _b = _a === void 0 ? this.props : _a,\n        reference = _b.reference,\n        record = _b.record,\n        resource = _b.resource,\n        target = _b.target,\n        filter = _b.filter,\n        source = _b.source;\n\n    var crudGetManyReference = this.props.crudGetManyReference;\n    var _c = this.state,\n        page = _c.page,\n        perPage = _c.perPage,\n        sort = _c.sort;\n    var relatedTo = nameRelatedTo(reference, record[source], resource, target, filter);\n    crudGetManyReference(reference, target, record[source], relatedTo, {\n      page: page,\n      perPage: perPage\n    }, sort, filter, source);\n  };\n\n  UnconnectedReferenceManyFieldController.prototype.render = function () {\n    var _a = this.props,\n        resource = _a.resource,\n        reference = _a.reference,\n        data = _a.data,\n        ids = _a.ids,\n        children = _a.children,\n        basePath = _a.basePath,\n        total = _a.total;\n    var _b = this.state,\n        page = _b.page,\n        perPage = _b.perPage;\n    var referenceBasePath = basePath.replace(resource, reference);\n    return children({\n      currentSort: this.state.sort,\n      data: data,\n      ids: ids,\n      loadedOnce: typeof ids !== 'undefined',\n      page: page,\n      perPage: perPage,\n      referenceBasePath: referenceBasePath,\n      setPage: this.setPage,\n      setPerPage: this.setPerPage,\n      setSort: this.setSort,\n      total: total\n    });\n  };\n\n  UnconnectedReferenceManyFieldController.defaultProps = {\n    filter: {},\n    perPage: 25,\n    sort: {\n      field: 'id',\n      order: 'DESC'\n    },\n    source: 'id'\n  };\n  return UnconnectedReferenceManyFieldController;\n}(Component);\n\nexport { UnconnectedReferenceManyFieldController };\n\nfunction mapStateToProps(state, props) {\n  var relatedTo = nameRelatedTo(props.reference, props.record[props.source], props.resource, props.target, props.filter);\n  return {\n    data: getReferences(state, props.reference, relatedTo),\n    ids: getIds(state, relatedTo),\n    total: getTotal(state, relatedTo)\n  };\n}\n\nvar ReferenceManyFieldController = connect(mapStateToProps, {\n  crudGetManyReference: crudGetManyReferenceAction\n})(UnconnectedReferenceManyFieldController);\nexport default ReferenceManyFieldController;","map":null,"metadata":{},"sourceType":"module"}