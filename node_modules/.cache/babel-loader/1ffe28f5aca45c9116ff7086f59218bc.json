{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.subscribe = subscribe;\nexports.createSourceEventStream = createSourceEventStream;\n\nvar _iterall = require('iterall');\n\nvar _execute = require('../execution/execute');\n\nvar _schema = require('../type/schema');\n\nvar _invariant = require('../jsutils/invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _mapAsyncIterator = require('./mapAsyncIterator');\n\nvar _mapAsyncIterator2 = _interopRequireDefault(_mapAsyncIterator);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Implements the \"Subscribe\" algorithm described in the GraphQL specification.\n *\n * Returns an AsyncIterator\n *\n * If the arguments to this function do not result in a legal execution context,\n * a GraphQLError will be thrown immediately explaining the invalid input.\n *\n * Accepts either an object with named arguments, or individual arguments.\n */\n\n/* eslint-disable no-redeclare */\n\n\nfunction subscribe(argsOrSchema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver) {\n  // Extract arguments from object args if provided.\n  var args = arguments.length === 1 ? argsOrSchema : undefined;\n  var schema = args ? args.schema : argsOrSchema;\n  return args ? subscribeImpl(schema, args.document, args.rootValue, args.contextValue, args.variableValues, args.operationName, args.fieldResolver, args.subscribeFieldResolver) : subscribeImpl(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver);\n}\n/**\n * Copyright (c) 2017, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n\n\nfunction subscribeImpl(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver) {\n  var subscription = createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, subscribeFieldResolver); // For each payload yielded from a subscription, map it over the normal\n  // GraphQL `execute` function, with `payload` as the rootValue.\n  // This implements the \"MapSourceToResponseEvent\" algorithm described in\n  // the GraphQL specification. The `execute` function provides the\n  // \"ExecuteSubscriptionEvent\" algorithm, as it is nearly identical to the\n  // \"ExecuteQuery\" algorithm, for which `execute` is also used.\n\n  return (0, _mapAsyncIterator2.default)(subscription, function (payload) {\n    return (0, _execute.execute)(schema, document, payload, contextValue, variableValues, operationName, fieldResolver);\n  });\n}\n/**\n * Implements the \"CreateSourceEventStream\" algorithm described in the\n * GraphQL specification, resolving the subscription source event stream.\n *\n * Returns an AsyncIterable, may through a GraphQLError.\n *\n * A Source Stream represents the sequence of events, each of which is\n * expected to be used to trigger a GraphQL execution for that event.\n *\n * This may be useful when hosting the stateful subscription service in a\n * different process or machine than the stateless GraphQL execution engine,\n * or otherwise separating these two steps. For more on this, see the\n * \"Supporting Subscriptions at Scale\" information in the GraphQL specification.\n */\n\n\nfunction createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver) {\n  // If arguments are missing or incorrect, throw an error.\n  (0, _execute.assertValidExecutionArguments)(schema, document, variableValues); // If a valid context cannot be created due to incorrect arguments,\n  // this will throw an error.\n\n  var exeContext = (0, _execute.buildExecutionContext)(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver);\n  var type = (0, _execute.getOperationRootType)(schema, exeContext.operation);\n  var fields = (0, _execute.collectFields)(exeContext, type, exeContext.operation.selectionSet, Object.create(null), Object.create(null));\n  var responseNames = Object.keys(fields);\n  var responseName = responseNames[0];\n  var fieldNodes = fields[responseName];\n  var fieldNode = fieldNodes[0];\n  var fieldDef = (0, _execute.getFieldDef)(schema, type, fieldNode.name.value);\n  !fieldDef ? (0, _invariant2.default)(0, 'This subscription is not defined by the schema.') : void 0; // Call the `subscribe()` resolver or the default resolver to produce an\n  // AsyncIterable yielding raw payloads.\n\n  var resolveFn = fieldDef.subscribe || exeContext.fieldResolver;\n  var info = (0, _execute.buildResolveInfo)(exeContext, fieldDef, fieldNodes, type, (0, _execute.addPath)(undefined, responseName)); // resolveFieldValueOrError implements the \"ResolveFieldEventStream\"\n  // algorithm from GraphQL specification. It differs from\n  // \"ResolveFieldValue\" due to providing a different `resolveFn`.\n\n  var subscription = (0, _execute.resolveFieldValueOrError)(exeContext, fieldDef, fieldNodes, resolveFn, rootValue, info);\n\n  if (subscription instanceof Error) {\n    throw subscription;\n  }\n\n  if (!(0, _iterall.isAsyncIterable)(subscription)) {\n    throw new Error('Subscription must return Async Iterable. ' + 'Received: ' + String(subscription));\n  }\n\n  return subscription;\n}","map":null,"metadata":{},"sourceType":"script"}