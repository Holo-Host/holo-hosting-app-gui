{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport lodashMemoize from 'lodash/memoize';\n/* eslint-disable no-underscore-dangle */\n\n/* @link http://stackoverflow.com/questions/46155/validate-email-address-in-javascript */\n\nvar EMAIL_REGEX = /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/; // eslint-disable-line no-useless-escape\n\nvar isEmpty = function isEmpty(value) {\n  return typeof value === 'undefined' || value === null || value === '';\n};\n\nvar getMessage = function getMessage(message, messageArgs, value, values, props) {\n  return typeof message === 'function' ? message(__assign({\n    args: messageArgs,\n    value: value,\n    values: values\n  }, props)) : props.translate(message, __assign({\n    _: message\n  }, messageArgs));\n}; // If we define validation functions directly in JSX, it will\n// result in a new function at every render, and then trigger infinite re-render.\n// Hence, we memoize every built-in validator to prevent a \"Maximum call stack\" error.\n\n\nvar memoize = function memoize(fn) {\n  return lodashMemoize(fn, function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    return JSON.stringify(args);\n  });\n};\n/**\n * Required validator\n *\n * Returns an error if the value is null, undefined, or empty\n *\n * @param {string|function} message\n *\n * @example\n *\n * const titleValidators = [required('The title is required')];\n * <TextInput name=\"title\" validate={titleValidators} />\n */\n\n\nexport var required = memoize(function (message) {\n  if (message === void 0) {\n    message = 'ra.validation.required';\n  }\n\n  return Object.assign(function (value, values, props) {\n    return isEmpty(value) ? getMessage(message, undefined, value, values, props) : undefined;\n  }, {\n    isRequired: true\n  });\n});\n/**\n * Minimum length validator\n *\n * Returns an error if the value has a length less than the parameter\n *\n * @param {integer} min\n * @param {string|function} message\n *\n * @example\n *\n * const passwordValidators = [minLength(10, 'Should be at least 10 characters')];\n * <TextInput type=\"password\" name=\"password\" validate={passwordValidators} />\n */\n\nexport var minLength = memoize(function (min, message) {\n  if (message === void 0) {\n    message = 'ra.validation.minLength';\n  }\n\n  return function (value, values, props) {\n    return !isEmpty(value) && value.length < min ? getMessage(message, {\n      min: min\n    }, value, values, props) : undefined;\n  };\n});\n/**\n * Maximum length validator\n *\n * Returns an error if the value has a length higher than the parameter\n *\n * @param {integer} max\n * @param {string|function} message\n *\n * @example\n *\n * const nameValidators = [maxLength(10, 'Should be at most 10 characters')];\n * <TextInput name=\"name\" validate={nameValidators} />\n */\n\nexport var maxLength = memoize(function (max, message) {\n  if (message === void 0) {\n    message = 'ra.validation.maxLength';\n  }\n\n  return function (value, values, props) {\n    return !isEmpty(value) && value.length > max ? getMessage(message, {\n      max: max\n    }, value, values, props) : undefined;\n  };\n});\n/**\n * Minimum validator\n *\n * Returns an error if the value is less than the parameter\n *\n * @param {integer} min\n * @param {string|function} message\n *\n * @example\n *\n * const fooValidators = [minValue(5, 'Should be more than 5')];\n * <NumberInput name=\"foo\" validate={fooValidators} />\n */\n\nexport var minValue = memoize(function (min, message) {\n  if (message === void 0) {\n    message = 'ra.validation.minValue';\n  }\n\n  return function (value, values, props) {\n    return !isEmpty(value) && value < min ? getMessage(message, {\n      min: min\n    }, value, values, props) : undefined;\n  };\n});\n/**\n * Maximum validator\n *\n * Returns an error if the value is higher than the parameter\n *\n * @param {integer} max\n * @param {string|function} message\n *\n * @example\n *\n * const fooValidators = [maxValue(10, 'Should be less than 10')];\n * <NumberInput name=\"foo\" validate={fooValidators} />\n */\n\nexport var maxValue = memoize(function (max, message) {\n  if (message === void 0) {\n    message = 'ra.validation.maxValue';\n  }\n\n  return function (value, values, props) {\n    return !isEmpty(value) && value > max ? getMessage(message, {\n      max: max\n    }, value, values, props) : undefined;\n  };\n});\n/**\n * Number validator\n *\n * Returns an error if the value is not a number\n *\n * @param {string|function} message\n *\n * @example\n *\n * const ageValidators = [number('Must be a number')];\n * <TextInput name=\"age\" validate={ageValidators} />\n */\n// tslint:disable-next-line:variable-name\n\nexport var number = memoize(function (message) {\n  if (message === void 0) {\n    message = 'ra.validation.number';\n  }\n\n  return function (value, values, props) {\n    return !isEmpty(value) && isNaN(Number(value)) ? getMessage(message, undefined, value, values, props) : undefined;\n  };\n});\n/**\n * Regular expression validator\n *\n * Returns an error if the value does not match the pattern given as parameter\n *\n * @param {RegExp} pattern\n * @param {string|function} message\n *\n * @example\n *\n * const zipValidators = [regex(/^\\d{5}(?:[-\\s]\\d{4})?$/, 'Must be a zip code')];\n * <TextInput name=\"zip\" validate={zipValidators} />\n */\n\nexport var regex = lodashMemoize(function (pattern, message) {\n  if (message === void 0) {\n    message = 'ra.validation.regex';\n  }\n\n  return function (value, values, props) {\n    return !isEmpty(value) && typeof value === 'string' && !pattern.test(value) ? getMessage(message, {\n      pattern: pattern\n    }, value, values, props) : undefined;\n  };\n}, function (pattern, message) {\n  return pattern.toString() + message;\n});\n/**\n * Email validator\n *\n * Returns an error if the value is not a valid email\n *\n * @param {string|function} message\n *\n * @example\n *\n * const emailValidators = [email('Must be an email')];\n * <TextInput name=\"email\" validate={emailValidators} />\n */\n\nexport var email = memoize(function (message) {\n  if (message === void 0) {\n    message = 'ra.validation.email';\n  }\n\n  return regex(EMAIL_REGEX, message);\n});\n\nvar oneOfTypeMessage = function oneOfTypeMessage(_a) {\n  var list = _a.list,\n      value = _a.value,\n      values = _a.values,\n      translate = _a.translate;\n  return translate('ra.validation.oneOf', {\n    options: list.join(', ')\n  });\n};\n/**\n * Choices validator\n *\n * Returns an error if the value is not among the list passed as parameter\n *\n * @param {array} list\n * @param {string|function} message\n *\n * @example\n *\n * const genderValidators = [choices(['male', 'female'], 'Must be either Male or Female')];\n * <TextInput name=\"gender\" validate={genderValidators} />\n */\n\n\nexport var choices = memoize(function (list, message) {\n  if (message === void 0) {\n    message = oneOfTypeMessage;\n  }\n\n  return function (value, values, props) {\n    return !isEmpty(value) && list.indexOf(value) === -1 ? getMessage(message, {\n      list: list\n    }, value, values, props) : undefined;\n  };\n});","map":null,"metadata":{},"sourceType":"module"}