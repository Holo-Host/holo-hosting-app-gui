{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport Autosuggest from 'react-autosuggest';\nimport Chip from '@material-ui/core/Chip';\nimport Paper from '@material-ui/core/Paper';\nimport Popper from '@material-ui/core/Popper';\nimport MenuItem from '@material-ui/core/MenuItem';\nimport { withStyles, createStyles } from '@material-ui/core/styles';\nimport parse from 'autosuggest-highlight/parse';\nimport match from 'autosuggest-highlight/match';\nimport blue from '@material-ui/core/colors/blue';\nimport compose from 'recompose/compose';\nimport classNames from 'classnames';\nimport { addField, translate, FieldTitle } from 'ra-core';\nimport AutocompleteArrayInputChip from './AutocompleteArrayInputChip';\n\nvar styles = function styles(theme) {\n  return createStyles({\n    container: {\n      flexGrow: 1,\n      position: 'relative'\n    },\n    root: {},\n    suggestionsContainerOpen: {\n      position: 'absolute',\n      marginBottom: theme.spacing.unit * 3,\n      zIndex: 2\n    },\n    suggestionsPaper: {\n      maxHeight: '50vh',\n      overflowY: 'auto'\n    },\n    suggestion: {\n      display: 'block',\n      fontFamily: theme.typography.fontFamily\n    },\n    suggestionText: {\n      fontWeight: 300\n    },\n    highlightedSuggestionText: {\n      fontWeight: 500\n    },\n    suggestionsList: {\n      margin: 0,\n      padding: 0,\n      listStyleType: 'none'\n    },\n    chip: {\n      marginRight: theme.spacing.unit\n    },\n    chipDisabled: {\n      pointerEvents: 'none'\n    },\n    chipFocused: {\n      backgroundColor: blue[300]\n    }\n  });\n};\n/**\n * An Input component for an autocomplete field, using an array of objects for the options\n *\n * Pass possible options as an array of objects in the 'choices' attribute.\n *\n * By default, the options are built from:\n *  - the 'id' property as the option value,\n *  - the 'name' property an the option text\n * @example\n * const choices = [\n *    { id: 'M', name: 'Male' },\n *    { id: 'F', name: 'Female' },\n * ];\n * <AutocompleteInput source=\"gender\" choices={choices} />\n *\n * You can also customize the properties to use for the option name and value,\n * thanks to the 'optionText' and 'optionValue' attributes.\n * @example\n * const choices = [\n *    { _id: 123, full_name: 'Leo Tolstoi', sex: 'M' },\n *    { _id: 456, full_name: 'Jane Austen', sex: 'F' },\n * ];\n * <AutocompleteInput source=\"author_id\" choices={choices} optionText=\"full_name\" optionValue=\"_id\" />\n *\n * `optionText` also accepts a function, so you can shape the option text at will:\n * @example\n * const choices = [\n *    { id: 123, first_name: 'Leo', last_name: 'Tolstoi' },\n *    { id: 456, first_name: 'Jane', last_name: 'Austen' },\n * ];\n * const optionRenderer = choice => `${choice.first_name} ${choice.last_name}`;\n * <AutocompleteInput source=\"author_id\" choices={choices} optionText={optionRenderer} />\n *\n * The choices are translated by default, so you can use translation identifiers as choices:\n * @example\n * const choices = [\n *    { id: 'M', name: 'myroot.gender.male' },\n *    { id: 'F', name: 'myroot.gender.female' },\n * ];\n *\n * However, in some cases (e.g. inside a `<ReferenceInput>`), you may not want\n * the choice to be translated. In that case, set the `translateChoice` prop to false.\n * @example\n * <AutocompleteInput source=\"gender\" choices={choices} translateChoice={false}/>\n *\n * The object passed as `options` props is passed to the material-ui <AutoComplete> component\n *\n * @example\n * <AutocompleteInput source=\"author_id\" options={{ fullWidth: true }} />\n */\n\n\nvar AutocompleteArrayInput =\n/** @class */\nfunction (_super) {\n  __extends(AutocompleteArrayInput, _super);\n\n  function AutocompleteArrayInput() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.initialInputValue = [];\n    _this.state = {\n      dirty: false,\n      inputValue: _this.initialInputValue,\n      searchText: '',\n      suggestions: []\n    };\n    _this.inputEl = null;\n    _this.anchorEl = null;\n\n    _this.getInputValue = function (inputValue) {\n      return inputValue === '' ? _this.initialInputValue : inputValue;\n    };\n\n    _this.getSuggestionValue = function (suggestion) {\n      return get(suggestion, _this.props.optionValue);\n    };\n\n    _this.getSuggestionText = function (suggestion) {\n      if (!suggestion) return '';\n      var _a = _this.props,\n          optionText = _a.optionText,\n          translate = _a.translate,\n          translateChoice = _a.translateChoice;\n      var suggestionLabel = typeof optionText === 'function' ? optionText(suggestion) : get(suggestion, optionText); // We explicitly call toString here because AutoSuggest expect a string\n\n      return translateChoice ? translate(suggestionLabel, {\n        _: suggestionLabel\n      }).toString() : suggestionLabel.toString();\n    };\n\n    _this.handleSuggestionSelected = function (event, _a) {\n      var suggestion = _a.suggestion,\n          method = _a.method;\n      var input = _this.props.input;\n      input.onChange((_this.state.inputValue || []).concat([_this.getSuggestionValue(suggestion)]));\n\n      if (method === 'enter') {\n        event.preventDefault();\n      }\n    };\n\n    _this.handleSuggestionsFetchRequested = function () {\n      var _a = _this.props,\n          choices = _a.choices,\n          inputValueMatcher = _a.inputValueMatcher;\n\n      _this.setState(function (_a) {\n        var searchText = _a.searchText;\n        return {\n          suggestions: choices.filter(function (suggestion) {\n            return inputValueMatcher(searchText, suggestion, _this.getSuggestionText);\n          })\n        };\n      });\n    };\n\n    _this.handleSuggestionsClearRequested = function () {\n      _this.updateFilter('');\n    };\n\n    _this.handleMatchSuggestionOrFilter = function (inputValue) {\n      _this.setState({\n        dirty: true,\n        searchText: inputValue\n      });\n\n      _this.updateFilter(inputValue);\n    };\n\n    _this.handleChange = function (event, _a) {\n      var newValue = _a.newValue,\n          method = _a.method;\n\n      switch (method) {\n        case 'type':\n        case 'escape':\n          {\n            _this.handleMatchSuggestionOrFilter(newValue);\n          }\n          break;\n      }\n    };\n\n    _this.renderInput = function (inputProps) {\n      var input = _this.props.input;\n\n      var autoFocus = inputProps.autoFocus,\n          className = inputProps.className,\n          classes = inputProps.classes,\n          isRequired = inputProps.isRequired,\n          label = inputProps.label,\n          meta = inputProps.meta,\n          onChange = inputProps.onChange,\n          resource = inputProps.resource,\n          source = inputProps.source,\n          value = inputProps.value,\n          ref = inputProps.ref,\n          _a = inputProps.options,\n          InputProps = _a.InputProps,\n          options = __rest(_a, [\"InputProps\"]),\n          other = __rest(inputProps, [\"autoFocus\", \"className\", \"classes\", \"isRequired\", \"label\", \"meta\", \"onChange\", \"resource\", \"source\", \"value\", \"ref\", \"options\"]);\n\n      if (typeof meta === 'undefined') {\n        throw new Error(\"The TextInput component wasn't called within a redux-form <Field>. Did you decorate it and forget to add the addField prop to your component? See https://marmelab.com/react-admin/Inputs.html#writing-your-own-input-component for details.\");\n      }\n\n      var touched = meta.touched,\n          error = meta.error,\n          _b = meta.helperText,\n          helperText = _b === void 0 ? false : _b; // We need to store the input reference for our Popper element containg the suggestions\n      // but Autosuggest also needs this reference (it provides the ref prop)\n\n      var storeInputRef = function storeInputRef(input) {\n        _this.inputEl = input;\n\n        _this.updateAnchorEl();\n\n        ref(input);\n      };\n\n      return React.createElement(AutocompleteArrayInputChip, __assign({\n        clearInputValueOnChange: true,\n        onUpdateInput: onChange,\n        onAdd: _this.handleAdd,\n        onDelete: _this.handleDelete,\n        value: _this.getInputValue(input.value),\n        inputRef: storeInputRef,\n        error: touched && error,\n        helperText: touched && error && helperText,\n        chipRenderer: _this.renderChip,\n        label: React.createElement(FieldTitle, {\n          label: label,\n          source: source,\n          resource: resource,\n          isRequired: isRequired\n        })\n      }, other, options));\n    };\n\n    _this.renderChip = function (_a, key) {\n      var value = _a.value,\n          isFocused = _a.isFocused,\n          isDisabled = _a.isDisabled,\n          handleClick = _a.handleClick,\n          handleDelete = _a.handleDelete;\n\n      var _b;\n\n      var _c = _this.props,\n          _d = _c.classes,\n          classes = _d === void 0 ? {} : _d,\n          choices = _c.choices;\n      var suggestion = choices.find(function (choice) {\n        return _this.getSuggestionValue(choice) === value;\n      });\n      return React.createElement(Chip, {\n        key: key,\n        className: classNames(classes.chip, (_b = {}, _b[classes.chipDisabled] = isDisabled, _b[classes.chipFocused] = isFocused, _b)),\n        onClick: handleClick,\n        onDelete: handleDelete,\n        label: _this.getSuggestionText(suggestion)\n      });\n    };\n\n    _this.handleAdd = function (chip) {\n      var _a = _this.props,\n          choices = _a.choices,\n          input = _a.input,\n          limitChoicesToValue = _a.limitChoicesToValue,\n          inputValueMatcher = _a.inputValueMatcher;\n      var filteredChoices = choices.filter(function (choice) {\n        return inputValueMatcher(chip, choice, _this.getSuggestionText);\n      });\n      var choice = filteredChoices.length === 1 ? filteredChoices[0] : filteredChoices.find(function (c) {\n        return _this.getSuggestionValue(c) === chip;\n      });\n\n      if (choice) {\n        return input.onChange((_this.state.inputValue || []).concat([_this.getSuggestionValue(choice)]));\n      }\n\n      if (limitChoicesToValue) {\n        // Ensure to reset the filter\n        _this.updateFilter('');\n\n        return;\n      }\n\n      input.onChange(_this.state.inputValue.concat([chip]));\n    };\n\n    _this.handleDelete = function (chip) {\n      var input = _this.props.input;\n      input.onChange(_this.state.inputValue.filter(function (value) {\n        return value !== chip;\n      }));\n    };\n\n    _this.renderSuggestionsContainer = function (autosuggestOptions) {\n      var _a = autosuggestOptions.containerProps,\n          className = _a.className,\n          containerProps = __rest(_a, [\"className\"]),\n          children = autosuggestOptions.children;\n\n      var _b = _this.props.classes,\n          classes = _b === void 0 ? {} : _b; // Force the Popper component to reposition the popup only when this.inputEl is moved to another location\n\n      _this.updateAnchorEl();\n\n      return React.createElement(Popper, {\n        className: className,\n        open: Boolean(children),\n        anchorEl: _this.anchorEl,\n        placement: \"bottom-start\"\n      }, React.createElement(Paper, __assign({\n        square: true,\n        className: classes.suggestionsPaper\n      }, containerProps), children));\n    };\n\n    _this.renderSuggestionComponent = function (_a) {\n      var suggestion = _a.suggestion,\n          query = _a.query,\n          isHighlighted = _a.isHighlighted,\n          props = __rest(_a, [\"suggestion\", \"query\", \"isHighlighted\"]);\n\n      return React.createElement(\"div\", __assign({}, props));\n    };\n\n    _this.renderSuggestion = function (suggestion, _a) {\n      var query = _a.query,\n          isHighlighted = _a.isHighlighted;\n\n      var label = _this.getSuggestionText(suggestion);\n\n      var matches = match(label, query);\n      var parts = parse(label, matches);\n      var _b = _this.props,\n          _c = _b.classes,\n          classes = _c === void 0 ? {} : _c,\n          suggestionComponent = _b.suggestionComponent;\n      return React.createElement(MenuItem, {\n        selected: isHighlighted,\n        component: suggestionComponent || _this.renderSuggestionComponent,\n        suggestion: suggestion,\n        query: query,\n        isHighlighted: isHighlighted\n      }, React.createElement(\"div\", null, parts.map(function (part, index) {\n        return part.highlight ? React.createElement(\"span\", {\n          key: index,\n          className: classes.highlightedSuggestionText\n        }, part.text) : React.createElement(\"strong\", {\n          key: index,\n          className: classes.suggestionText\n        }, part.text);\n      })));\n    };\n\n    _this.handleFocus = function () {\n      var input = _this.props.input;\n      input && input.onFocus && input.onFocus();\n    };\n\n    _this.updateFilter = function (value) {\n      var _a = _this.props,\n          setFilter = _a.setFilter,\n          choices = _a.choices;\n\n      if (_this.previousFilterValue !== value) {\n        if (setFilter) {\n          setFilter(value);\n        } else {\n          _this.setState({\n            searchText: value,\n            suggestions: choices.filter(function (choice) {\n              return _this.getSuggestionText(choice).toLowerCase().includes(value.toLowerCase());\n            })\n          });\n        }\n      }\n\n      _this.previousFilterValue = value;\n    };\n\n    _this.shouldRenderSuggestions = function (val) {\n      var shouldRenderSuggestions = _this.props.shouldRenderSuggestions;\n\n      if (shouldRenderSuggestions !== undefined && typeof shouldRenderSuggestions === 'function') {\n        return shouldRenderSuggestions(val);\n      }\n\n      return true;\n    };\n\n    return _this;\n  }\n\n  AutocompleteArrayInput.prototype.componentWillMount = function () {\n    this.setState({\n      inputValue: this.getInputValue(this.props.input.value),\n      suggestions: this.props.choices\n    });\n  };\n\n  AutocompleteArrayInput.prototype.componentWillReceiveProps = function (nextProps) {\n    var _this = this;\n\n    var choices = nextProps.choices,\n        input = nextProps.input,\n        inputValueMatcher = nextProps.inputValueMatcher;\n\n    if (!isEqual(this.getInputValue(input.value), this.state.inputValue)) {\n      this.setState({\n        inputValue: this.getInputValue(input.value),\n        dirty: false,\n        suggestions: this.props.choices\n      }); // Ensure to reset the filter\n\n      this.updateFilter('');\n    } else if (!isEqual(choices, this.props.choices)) {\n      this.setState(function (_a) {\n        var searchText = _a.searchText;\n        return {\n          suggestions: choices.filter(function (suggestion) {\n            return inputValueMatcher(searchText, suggestion, _this.getSuggestionText);\n          })\n        };\n      });\n    }\n  };\n\n  AutocompleteArrayInput.prototype.updateAnchorEl = function () {\n    if (!this.inputEl) {\n      return;\n    }\n\n    var inputPosition = this.inputEl.getBoundingClientRect();\n\n    if (!this.anchorEl) {\n      this.anchorEl = {\n        getBoundingClientRect: function getBoundingClientRect() {\n          return inputPosition;\n        }\n      };\n    } else {\n      var anchorPosition = this.anchorEl.getBoundingClientRect();\n\n      if (anchorPosition.x !== inputPosition.x || anchorPosition.y !== inputPosition.y) {\n        this.anchorEl = {\n          getBoundingClientRect: function getBoundingClientRect() {\n            return inputPosition;\n          }\n        };\n      }\n    }\n  };\n\n  AutocompleteArrayInput.prototype.render = function () {\n    var _a = this.props,\n        alwaysRenderSuggestions = _a.alwaysRenderSuggestions,\n        _b = _a.classes,\n        classes = _b === void 0 ? {} : _b,\n        isRequired = _a.isRequired,\n        label = _a.label,\n        meta = _a.meta,\n        resource = _a.resource,\n        source = _a.source,\n        className = _a.className,\n        options = _a.options;\n    var _c = this.state,\n        suggestions = _c.suggestions,\n        searchText = _c.searchText;\n    return React.createElement(Autosuggest, {\n      theme: {\n        container: classes.container,\n        suggestionsContainerOpen: classes.suggestionsContainerOpen,\n        suggestionsList: classes.suggestionsList,\n        suggestion: classes.suggestion\n      },\n      renderInputComponent: this.renderInput,\n      suggestions: suggestions,\n      alwaysRenderSuggestions: alwaysRenderSuggestions,\n      onSuggestionSelected: this.handleSuggestionSelected,\n      onSuggestionsFetchRequested: this.handleSuggestionsFetchRequested,\n      onSuggestionsClearRequested: this.handleSuggestionsClearRequested,\n      renderSuggestionsContainer: this.renderSuggestionsContainer,\n      getSuggestionValue: this.getSuggestionText,\n      renderSuggestion: this.renderSuggestion,\n      shouldRenderSuggestions: this.shouldRenderSuggestions,\n      inputProps: {\n        blurBehavior: 'add',\n        className: className,\n        classes: classes,\n        isRequired: isRequired,\n        label: label,\n        meta: meta,\n        onChange: this.handleChange,\n        resource: resource,\n        source: source,\n        value: searchText,\n        onFocus: this.handleFocus,\n        options: options\n      }\n    });\n  };\n\n  return AutocompleteArrayInput;\n}(React.Component);\n\nexport { AutocompleteArrayInput };\nAutocompleteArrayInput.propTypes = {\n  allowEmpty: PropTypes.bool,\n  alwaysRenderSuggestions: PropTypes.bool,\n  choices: PropTypes.arrayOf(PropTypes.object),\n  classes: PropTypes.object,\n  className: PropTypes.string,\n  InputProps: PropTypes.object,\n  input: PropTypes.object,\n  inputValueMatcher: PropTypes.func,\n  isRequired: PropTypes.bool,\n  label: PropTypes.string,\n  limitChoicesToValue: PropTypes.bool,\n  meta: PropTypes.object,\n  options: PropTypes.object,\n  optionText: PropTypes.oneOfType([PropTypes.string, PropTypes.func]).isRequired,\n  optionValue: PropTypes.string.isRequired,\n  resource: PropTypes.string,\n  setFilter: PropTypes.func,\n  shouldRenderSuggestions: PropTypes.func,\n  source: PropTypes.string,\n  suggestionComponent: PropTypes.func,\n  translate: PropTypes.func.isRequired,\n  translateChoice: PropTypes.bool.isRequired\n};\nAutocompleteArrayInput.defaultProps = {\n  choices: [],\n  options: {},\n  optionText: 'name',\n  optionValue: 'id',\n  limitChoicesToValue: false,\n  translateChoice: true,\n  inputValueMatcher: function inputValueMatcher(input, suggestion, getOptionText) {\n    return getOptionText(suggestion).toLowerCase().trim().includes(input.toLowerCase().trim());\n  }\n};\nexport default compose(addField, translate, withStyles(styles))(AutocompleteArrayInput);","map":null,"metadata":{},"sourceType":"module"}