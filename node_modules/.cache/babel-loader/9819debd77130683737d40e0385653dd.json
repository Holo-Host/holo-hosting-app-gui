{"ast":null,"code":"'use strict';\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');\n\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);\n\nvar _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar FetchMock = {};\n\nFetchMock.callsFilteredByName = function (name) {\n  if (name === true) {\n    return this._allCalls.filter(function (call) {\n      return !call.unmatched;\n    });\n  }\n\n  if (name === false) {\n    return this._allCalls.filter(function (call) {\n      return call.unmatched;\n    });\n  }\n\n  if (typeof name === 'undefined') {\n    return this._allCalls;\n  }\n\n  if (this._calls[name]) {\n    return this._calls[name];\n  }\n\n  return this._allCalls.filter(function (_ref) {\n    var _ref2 = (0, _slicedToArray3.default)(_ref, 1),\n        url = _ref2[0];\n\n    return url === name || url.url === name;\n  });\n};\n\nFetchMock.calls = function (name) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof options === 'string') {\n    options = {\n      method: options\n    };\n  }\n\n  var calls = this.callsFilteredByName(name);\n\n  if (options.method) {\n    var testMethod = options.method.toLowerCase();\n    calls = calls.filter(function (_ref3) {\n      var _ref4 = (0, _slicedToArray3.default)(_ref3, 2),\n          url = _ref4[0],\n          _ref4$ = _ref4[1],\n          opts = _ref4$ === undefined ? {} : _ref4$;\n\n      var method = (url.method || opts.method || 'get').toLowerCase();\n      return method === testMethod;\n    });\n  }\n\n  return calls;\n};\n\nFetchMock.lastCall = function (name, options) {\n  return [].concat((0, _toConsumableArray3.default)(this.calls(name, options))).pop();\n};\n\nFetchMock.normalizeLastCall = function (name, options) {\n  var call = this.lastCall(name, options) || [];\n\n  if (this.config.Request.prototype.isPrototypeOf(call[0])) {\n    return [call[0].url, call[0]];\n  }\n\n  return call;\n};\n\nFetchMock.lastUrl = function (name, options) {\n  return this.normalizeLastCall(name, options)[0];\n};\n\nFetchMock.lastOptions = function (name, options) {\n  return this.normalizeLastCall(name, options)[1];\n};\n\nFetchMock.called = function (name, options) {\n  return !!this.calls(name, options).length;\n};\n\nFetchMock.flush = function () {\n  return _promise2.default.all(this._holdingPromises);\n};\n\nFetchMock.done = function (name, options) {\n  var _this = this;\n\n  var names = name && typeof name !== 'boolean' ? [{\n    name: name\n  }] : this.routes; // Can't use array.every because\n  // a) not widely supported\n  // b) would exit after first failure, which would break the logging\n\n  return names.map(function (_ref5) {\n    var name = _ref5.name,\n        method = _ref5.method; // HACK - this is horrible. When the api is eventually updated to update other\n    // filters other than a method string it will break... but for now it's ok-ish\n\n    method = options || method;\n\n    if (!_this.called(name, method)) {\n      console.warn('Warning: ' + name + ' not called'); // eslint-disable-line\n\n      return false;\n    } // would use array.find... but again not so widely supported\n\n\n    var expectedTimes = (_this.routes.filter(function (r) {\n      return r.name === name && r.method === method;\n    }) || [{}])[0].repeat;\n\n    if (!expectedTimes) {\n      return true;\n    }\n\n    var actualTimes = _this.calls(name, method).length;\n\n    if (expectedTimes > actualTimes) {\n      console.warn('Warning: ' + name + ' only called ' + actualTimes + ' times, but ' + expectedTimes + ' expected'); // eslint-disable-line\n\n      return false;\n    } else {\n      return true;\n    }\n  }).filter(function (bool) {\n    return !bool;\n  }).length === 0;\n};\n\nmodule.exports = FetchMock;","map":null,"metadata":{},"sourceType":"script"}