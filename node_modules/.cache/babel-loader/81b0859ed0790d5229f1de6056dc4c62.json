{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { connect } from 'react-redux';\nimport get from 'lodash/get';\nimport { startUndoable } from '../actions/undoActions';\n\nvar mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return {\n    dataProvider: function dataProvider(type, resource, payload, meta) {\n      if (meta === void 0) {\n        meta = {};\n      }\n\n      return new Promise(function (resolve, reject) {\n        var action = {\n          type: 'CUSTOM_FETCH',\n          payload: payload,\n          meta: __assign({}, meta, {\n            resource: resource,\n            fetch: type,\n            onSuccess: __assign({}, get(meta, 'onSuccess', {}), {\n              callback: function callback(_a) {\n                var response = _a.payload;\n                return resolve(response);\n              }\n            }),\n            onFailure: __assign({}, get(meta, 'onFailure', {}), {\n              callback: function callback(_a) {\n                var error = _a.error;\n                return reject(new Error(error.message ? error.message : error));\n              }\n            })\n          })\n        };\n        return meta.undoable ? dispatch(startUndoable(action)) : dispatch(action);\n      });\n    },\n    dispatch: dispatch\n  };\n};\n/**\n * Higher-order component for fetching the dataProvider\n *\n * Injects a dataProvider function prop, which behaves just like\n * the dataProvider function (same signature, returns a Promise), but\n * uses Redux under the hood. The benefit is that react-admin tracks\n * the loading state when using this function, and shows the loader animation\n * while the dataProvider is waiting for a response.\n *\n * In addition to the 3 parameters of the dataProvider function (verb, resource, payload),\n * the injected dataProvider prop accepts a fourth parameter, an object literal\n * which may contain side effects, of make the action optimistic (with undoable: true).\n *\n * As it uses connect() from react-redux, this HOC also injects the dispatch prop,\n * allowing developers to dispatch additional actions upon completion.\n *\n * @example\n *\n * import { withDataProvider, showNotification } from 'react-admin';\n * class PostList extends Component {\n *     state = {\n *         posts: [],\n *     }\n *\n *     componentDidMount() {\n *         const { dataProvider, dispatch } = this.props;\n *         dataProvider('GET_LIST', 'posts', { filter: { status: 'pending' }})\n *            .then(({ data: posts }) => this.setState({ posts }))\n *            .catch(error => dispatch(showNotification(error.message, 'error')))\n *     }\n *\n *     render() {\n *         const { posts } = this.state;\n *         return (\n *            <Fragment>\n *                {posts.map((post, index) => <PostDetail post={post} key={key} />)}\n *            </Fragment>\n *         );\n *     }\n * }\n *\n * PostList.propTypes = {\n *     dataProvider: PropTypes.func.isRequired,\n * };\n *\n * export default withDataProvider(PostList);\n */\n\n\nvar withDataProvider = function withDataProvider(Component) {\n  return connect(null, mapDispatchToProps)(Component);\n};\n\nexport default withDataProvider;","map":null,"metadata":{},"sourceType":"module"}