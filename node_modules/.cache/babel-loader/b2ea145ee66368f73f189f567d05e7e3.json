{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { Component } from 'react';\nimport { connect } from 'react-redux';\nimport debounce from 'lodash/debounce';\nimport compose from 'recompose/compose';\nimport { createSelector } from 'reselect';\nimport isEqual from 'lodash/isEqual';\nimport { crudGetManyAccumulate as crudGetManyAccumulateAction, crudGetMatchingAccumulate as crudGetMatchingAccumulateAction } from '../../actions/accumulateActions';\nimport { getPossibleReferences, getPossibleReferenceValues, getReferenceResource } from '../../reducer';\nimport { getStatusForInput as getDataStatus } from './referenceDataStatus';\nimport withTranslate from '../../i18n/translate';\n\nvar defaultReferenceSource = function defaultReferenceSource(resource, source) {\n  return resource + \"@\" + source;\n};\n/**\n * An Input component for choosing a reference record. Useful for foreign keys.\n *\n * This component fetches the possible values in the reference resource\n * (using the `CRUD_GET_MATCHING` REST method), then delegates rendering\n * to a subcomponent, to which it passes the possible choices\n * as the `choices` attribute.\n *\n * Use it with a selector component as child, like `<AutocompleteInput>`,\n * `<SelectInput>`, or `<RadioButtonGroupInput>`.\n *\n * @example\n * export const CommentEdit = (props) => (\n *     <Edit {...props}>\n *         <SimpleForm>\n *             <ReferenceInput label=\"Post\" source=\"post_id\" reference=\"posts\">\n *                 <AutocompleteInput optionText=\"title\" />\n *             </ReferenceInput>\n *         </SimpleForm>\n *     </Edit>\n * );\n *\n * @example\n * export const CommentEdit = (props) => (\n *     <Edit {...props}>\n *         <SimpleForm>\n *             <ReferenceInput label=\"Post\" source=\"post_id\" reference=\"posts\">\n *                 <SelectInput optionText=\"title\" />\n *             </ReferenceInput>\n *         </SimpleForm>\n *     </Edit>\n * );\n *\n * By default, restricts the possible values to 25. You can extend this limit\n * by setting the `perPage` prop.\n *\n * @example\n * <ReferenceInput\n *      source=\"post_id\"\n *      reference=\"posts\"\n *      perPage={100}>\n *     <SelectInput optionText=\"title\" />\n * </ReferenceInput>\n *\n * By default, orders the possible values by id desc. You can change this order\n * by setting the `sort` prop (an object with `field` and `order` properties).\n *\n * @example\n * <ReferenceInput\n *      source=\"post_id\"\n *      reference=\"posts\"\n *      sort={{ field: 'title', order: 'ASC' }}>\n *     <SelectInput optionText=\"title\" />\n * </ReferenceInput>\n *\n * Also, you can filter the query used to populate the possible values. Use the\n * `filter` prop for that.\n *\n * @example\n * <ReferenceInput\n *      source=\"post_id\"\n *      reference=\"posts\"\n *      filter={{ is_published: true }}>\n *     <SelectInput optionText=\"title\" />\n * </ReferenceInput>\n *\n * The enclosed component may filter results. ReferenceInput passes a `setFilter`\n * function as prop to its child component. It uses the value to create a filter\n * for the query - by default { q: [searchText] }. You can customize the mapping\n * searchText => searchQuery by setting a custom `filterToQuery` function prop:\n *\n * @example\n * <ReferenceInput\n *      source=\"post_id\"\n *      reference=\"posts\"\n *      filterToQuery={searchText => ({ title: searchText })}>\n *     <SelectInput optionText=\"title\" />\n * </ReferenceInput>\n */\n\n\nvar UnconnectedReferenceInputController =\n/** @class */\nfunction (_super) {\n  __extends(UnconnectedReferenceInputController, _super);\n\n  function UnconnectedReferenceInputController(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.setFilter = function (filter) {\n      if (filter !== _this.state.filter) {\n        _this.setState({\n          filter: _this.props.filterToQuery(filter)\n        }, _this.fetchOptions);\n      }\n    };\n\n    _this.setPagination = function (pagination) {\n      if (pagination !== _this.state.pagination) {\n        _this.setState({\n          pagination: pagination\n        }, _this.fetchOptions);\n      }\n    };\n\n    _this.setSort = function (sort) {\n      if (sort !== _this.state.sort) {\n        _this.setState({\n          sort: sort\n        }, _this.fetchOptions);\n      }\n    };\n\n    _this.fetchReference = function (props) {\n      if (props === void 0) {\n        props = _this.props;\n      }\n\n      var crudGetManyAccumulate = props.crudGetManyAccumulate,\n          input = props.input,\n          reference = props.reference;\n      var id = input.value;\n\n      if (id) {\n        crudGetManyAccumulate(reference, [id]);\n      }\n    };\n\n    _this.fetchOptions = function (props) {\n      if (props === void 0) {\n        props = _this.props;\n      }\n\n      var crudGetMatchingAccumulate = props.crudGetMatchingAccumulate,\n          filterFromProps = props.filter,\n          reference = props.reference,\n          referenceSource = props.referenceSource,\n          resource = props.resource,\n          source = props.source;\n      var _a = _this.state,\n          pagination = _a.pagination,\n          sort = _a.sort,\n          filter = _a.filter;\n      crudGetMatchingAccumulate(reference, referenceSource(resource, source), pagination, sort, __assign({}, filterFromProps, filter));\n    };\n\n    var perPage = props.perPage,\n        sort = props.sort,\n        filter = props.filter;\n    _this.state = {\n      pagination: {\n        page: 1,\n        perPage: perPage\n      },\n      sort: sort,\n      filter: filter\n    };\n    _this.debouncedSetFilter = debounce(_this.setFilter.bind(_this), 500);\n    return _this;\n  }\n\n  UnconnectedReferenceInputController.prototype.componentDidMount = function () {\n    this.fetchReferenceAndOptions(this.props);\n  };\n\n  UnconnectedReferenceInputController.prototype.componentWillReceiveProps = function (nextProps) {\n    if ((this.props.record || {\n      id: undefined\n    }).id !== (nextProps.record || {\n      id: undefined\n    }).id) {\n      this.fetchReferenceAndOptions(nextProps);\n    } else if (this.props.input.value !== nextProps.input.value) {\n      this.fetchReference(nextProps);\n    } else if (!isEqual(nextProps.filter, this.props.filter) || !isEqual(nextProps.sort, this.props.sort) || nextProps.perPage !== this.props.perPage) {\n      this.setState(function (state) {\n        return {\n          filter: nextProps.filter,\n          pagination: __assign({}, state.pagination, {\n            perPage: nextProps.perPage\n          }),\n          sort: nextProps.sort\n        };\n      }, this.fetchOptions);\n    }\n  };\n\n  UnconnectedReferenceInputController.prototype.fetchReferenceAndOptions = function (props) {\n    this.fetchReference(props);\n    this.fetchOptions(props);\n  };\n\n  UnconnectedReferenceInputController.prototype.render = function () {\n    var _a = this.props,\n        input = _a.input,\n        referenceRecord = _a.referenceRecord,\n        matchingReferences = _a.matchingReferences,\n        onChange = _a.onChange,\n        children = _a.children,\n        translate = _a.translate;\n    var _b = this.state,\n        pagination = _b.pagination,\n        sort = _b.sort,\n        filter = _b.filter;\n    var dataStatus = getDataStatus({\n      input: input,\n      matchingReferences: matchingReferences,\n      referenceRecord: referenceRecord,\n      translate: translate\n    });\n    return children({\n      choices: dataStatus.choices,\n      error: dataStatus.error,\n      isLoading: dataStatus.waiting,\n      onChange: onChange,\n      filter: filter,\n      setFilter: this.debouncedSetFilter,\n      pagination: pagination,\n      setPagination: this.setPagination,\n      sort: sort,\n      setSort: this.setSort,\n      warning: dataStatus.warning\n    });\n  };\n\n  UnconnectedReferenceInputController.defaultProps = {\n    allowEmpty: false,\n    filter: {},\n    filterToQuery: function filterToQuery(searchText) {\n      return {\n        q: searchText\n      };\n    },\n    matchingReferences: null,\n    perPage: 25,\n    sort: {\n      field: 'id',\n      order: 'DESC'\n    },\n    referenceRecord: null,\n    referenceSource: defaultReferenceSource\n  };\n  return UnconnectedReferenceInputController;\n}(Component);\n\nexport { UnconnectedReferenceInputController };\n\nvar makeMapStateToProps = function makeMapStateToProps() {\n  return createSelector([getReferenceResource, getPossibleReferenceValues, function (_, props) {\n    return props.input.value;\n  }], function (referenceState, possibleValues, inputId) {\n    return {\n      matchingReferences: getPossibleReferences(referenceState, possibleValues, [inputId]),\n      referenceRecord: referenceState && referenceState.data[inputId]\n    };\n  });\n};\n\nvar ReferenceInputController = compose(withTranslate, connect(makeMapStateToProps(), {\n  crudGetManyAccumulate: crudGetManyAccumulateAction,\n  crudGetMatchingAccumulate: crudGetMatchingAccumulateAction\n}))(UnconnectedReferenceInputController);\nReferenceInputController.defaultProps = {\n  referenceSource: defaultReferenceSource\n};\nexport default ReferenceInputController;","map":null,"metadata":{},"sourceType":"module"}