{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unknownDirectiveMessage = unknownDirectiveMessage;\nexports.misplacedDirectiveMessage = misplacedDirectiveMessage;\nexports.KnownDirectives = KnownDirectives;\n\nvar _error = require('../../error');\n\nvar _find = require('../../jsutils/find');\n\nvar _find2 = _interopRequireDefault(_find);\n\nvar _kinds = require('../../language/kinds');\n\nvar Kind = _interopRequireWildcard(_kinds);\n\nvar _directives = require('../../type/directives');\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction unknownDirectiveMessage(directiveName) {\n  return 'Unknown directive \"' + directiveName + '\".';\n}\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n\nfunction misplacedDirectiveMessage(directiveName, location) {\n  return 'Directive \"' + directiveName + '\" may not be used on ' + location + '.';\n}\n/**\n * Known directives\n *\n * A GraphQL document is only valid if all `@directives` are known by the\n * schema and legally positioned.\n */\n\n\nfunction KnownDirectives(context) {\n  return {\n    Directive: function Directive(node, key, parent, path, ancestors) {\n      var directiveDef = (0, _find2.default)(context.getSchema().getDirectives(), function (def) {\n        return def.name === node.name.value;\n      });\n\n      if (!directiveDef) {\n        context.reportError(new _error.GraphQLError(unknownDirectiveMessage(node.name.value), [node]));\n        return;\n      }\n\n      var candidateLocation = getDirectiveLocationForASTPath(ancestors);\n\n      if (!candidateLocation) {\n        context.reportError(new _error.GraphQLError(misplacedDirectiveMessage(node.name.value, node.type), [node]));\n      } else if (directiveDef.locations.indexOf(candidateLocation) === -1) {\n        context.reportError(new _error.GraphQLError(misplacedDirectiveMessage(node.name.value, candidateLocation), [node]));\n      }\n    }\n  };\n}\n\nfunction getDirectiveLocationForASTPath(ancestors) {\n  var appliedTo = ancestors[ancestors.length - 1];\n\n  switch (appliedTo.kind) {\n    case Kind.OPERATION_DEFINITION:\n      switch (appliedTo.operation) {\n        case 'query':\n          return _directives.DirectiveLocation.QUERY;\n\n        case 'mutation':\n          return _directives.DirectiveLocation.MUTATION;\n\n        case 'subscription':\n          return _directives.DirectiveLocation.SUBSCRIPTION;\n      }\n\n      break;\n\n    case Kind.FIELD:\n      return _directives.DirectiveLocation.FIELD;\n\n    case Kind.FRAGMENT_SPREAD:\n      return _directives.DirectiveLocation.FRAGMENT_SPREAD;\n\n    case Kind.INLINE_FRAGMENT:\n      return _directives.DirectiveLocation.INLINE_FRAGMENT;\n\n    case Kind.FRAGMENT_DEFINITION:\n      return _directives.DirectiveLocation.FRAGMENT_DEFINITION;\n\n    case Kind.SCHEMA_DEFINITION:\n      return _directives.DirectiveLocation.SCHEMA;\n\n    case Kind.SCALAR_TYPE_DEFINITION:\n      return _directives.DirectiveLocation.SCALAR;\n\n    case Kind.OBJECT_TYPE_DEFINITION:\n      return _directives.DirectiveLocation.OBJECT;\n\n    case Kind.FIELD_DEFINITION:\n      return _directives.DirectiveLocation.FIELD_DEFINITION;\n\n    case Kind.INTERFACE_TYPE_DEFINITION:\n      return _directives.DirectiveLocation.INTERFACE;\n\n    case Kind.UNION_TYPE_DEFINITION:\n      return _directives.DirectiveLocation.UNION;\n\n    case Kind.ENUM_TYPE_DEFINITION:\n      return _directives.DirectiveLocation.ENUM;\n\n    case Kind.ENUM_VALUE_DEFINITION:\n      return _directives.DirectiveLocation.ENUM_VALUE;\n\n    case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n      return _directives.DirectiveLocation.INPUT_OBJECT;\n\n    case Kind.INPUT_VALUE_DEFINITION:\n      var parentNode = ancestors[ancestors.length - 3];\n      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? _directives.DirectiveLocation.INPUT_FIELD_DEFINITION : _directives.DirectiveLocation.ARGUMENT_DEFINITION;\n  }\n}","map":null,"metadata":{},"sourceType":"script"}