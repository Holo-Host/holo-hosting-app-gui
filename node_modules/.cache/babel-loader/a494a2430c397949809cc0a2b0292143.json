{"ast":null,"code":"'use strict';\n\nvar _create = require('babel-runtime/core-js/object/create');\n\nvar _create2 = _interopRequireDefault(_create);\n\nvar _stringify = require('babel-runtime/core-js/json/stringify');\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _keys = require('babel-runtime/core-js/object/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _typeof2 = require('babel-runtime/helpers/typeof');\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar responseConfigProps = ['body', 'headers', 'throws', 'status', 'redirectUrl', 'includeContentLength', 'sendAsJson'];\n\nmodule.exports = function () {\n  function ResponseBuilder(url, responseConfig, fetchMock) {\n    (0, _classCallCheck3.default)(this, ResponseBuilder);\n    this.url = (typeof url === 'undefined' ? 'undefined' : (0, _typeof3.default)(url)) === 'object' ? url.url : url;\n    this.responseConfig = responseConfig;\n    this.fetchMockConfig = fetchMock.config;\n    this.statusTextMap = fetchMock.statusTextMap;\n    this.Response = fetchMock.config.Response;\n    this.Headers = fetchMock.config.Headers;\n  }\n\n  (0, _createClass3.default)(ResponseBuilder, [{\n    key: 'exec',\n    value: function exec() {\n      this.normalizeResponseConfig();\n      this.constructFetchOpts();\n      this.constructResponseBody();\n      return this.redirect(new this.Response(this.body, this.opts));\n    }\n  }, {\n    key: 'sendAsObject',\n    value: function sendAsObject() {\n      var _this = this;\n\n      if (responseConfigProps.some(function (prop) {\n        return _this.responseConfig[prop];\n      })) {\n        if ((0, _keys2.default)(this.responseConfig).every(function (key) {\n          return responseConfigProps.includes(key);\n        })) {\n          return false;\n        } else {\n          return true;\n        }\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: 'normalizeResponseConfig',\n    value: function normalizeResponseConfig() {\n      // If the response config looks like a status, start to generate a simple response\n      if (typeof this.responseConfig === 'number') {\n        this.responseConfig = {\n          status: this.responseConfig\n        }; // If the response config is not an object, or is an object that doesn't use\n        // any reserved properties, assume it is meant to be the body of the response\n      } else if (typeof this.responseConfig === 'string' || this.sendAsObject()) {\n        this.responseConfig = {\n          body: this.responseConfig\n        };\n      }\n    }\n  }, {\n    key: 'validateStatus',\n    value: function validateStatus(status) {\n      if (!status) {\n        return 200;\n      }\n\n      if (typeof status === 'number' && parseInt(status, 10) !== status && status >= 200 || status < 600) {\n        return status;\n      }\n\n      throw new TypeError('Invalid status ' + status + ' passed on response object.\\nTo respond with a JSON object that has status as a property assign the object to body\\ne.g. {\"body\": {\"status: \"registered\"}}');\n    }\n  }, {\n    key: 'constructFetchOpts',\n    value: function constructFetchOpts() {\n      this.opts = this.responseConfig.opts || {};\n      this.opts.url = this.responseConfig.redirectUrl || this.url;\n      this.opts.status = this.validateStatus(this.responseConfig.status);\n      this.opts.statusText = this.statusTextMap['' + this.opts.status]; // Set up response headers. The empty object is to cope with\n      // new Headers(undefined) throwing in Chrome\n      // https://code.google.com/p/chromium/issues/detail?id=335871\n\n      this.opts.headers = new this.Headers(this.responseConfig.headers || {});\n    }\n  }, {\n    key: 'getOption',\n    value: function getOption(name) {\n      return this.responseConfig[name] === undefined ? this.fetchMockConfig[name] : this.responseConfig[name];\n    }\n  }, {\n    key: 'constructResponseBody',\n    value: function constructResponseBody() {\n      // start to construct the body\n      var body = this.responseConfig.body; // convert to json if we need to\n\n      if (this.getOption('sendAsJson') && this.responseConfig.body != null && (typeof body === 'undefined' ? 'undefined' : (0, _typeof3.default)(body)) === 'object') {\n        //eslint-disable-line\n        body = (0, _stringify2.default)(body);\n\n        if (!this.opts.headers.has('Content-Type')) {\n          this.opts.headers.set('Content-Type', 'application/json');\n        }\n      } // add a Content-Length header if we need to\n\n\n      if (this.getOption('includeContentLength') && typeof body === 'string' && !this.opts.headers.has('Content-Length')) {\n        this.opts.headers.set('Content-Length', body.length.toString());\n      } // On the server we need to manually construct the readable stream for the\n      // Response object (on the client this done automatically)\n\n\n      if (this.stream) {\n        var s = new this.stream.Readable();\n\n        if (body != null) {\n          //eslint-disable-line\n          s.push(body, 'utf-8');\n        }\n\n        s.push(null);\n        body = s;\n      }\n\n      this.body = body;\n    }\n  }, {\n    key: 'redirect',\n    value: function redirect(response) {\n      // When mocking a followed redirect we must wrap the response in an object\n      // which sets the redirected flag (not a writable property on the actual\n      // response)\n      if (this.responseConfig.redirectUrl) {\n        response = (0, _create2.default)(response, {\n          redirected: {\n            value: true\n          },\n          url: {\n            value: this.responseConfig.redirectUrl\n          },\n          // TODO extend to all other methods and properties as requested by users\n          // Such a nasty hack\n          text: {\n            value: response.text.bind(response)\n          },\n          json: {\n            value: response.json.bind(response)\n          }\n        });\n      }\n\n      return response;\n    }\n  }]);\n  return ResponseBuilder;\n}();","map":null,"metadata":{},"sourceType":"script"}