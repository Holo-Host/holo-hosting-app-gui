{"ast":null,"code":"import { graphql } from './graphql';\nexport function filter(doc, data) {\n  var resolver = function resolver(fieldName, root, args, context, info) {\n    return root[info.resultKey];\n  };\n\n  return graphql(resolver, doc, data);\n} // TODO: we should probably make check call propType and then throw,\n// rather than the other way round, to avoid constructing stack traces\n// for things like oneOf uses in React. At this stage I doubt many people\n// are using this like that, but in the future, who knows?\n\nexport function check(doc, data) {\n  var resolver = function resolver(fieldName, root, args, context, info) {\n    if (!{}.hasOwnProperty.call(root, info.resultKey)) {\n      throw new Error(info.resultKey + \" missing on \" + root);\n    }\n\n    return root[info.resultKey];\n  };\n\n  graphql(resolver, doc, data, {}, {}, {\n    fragmentMatcher: function fragmentMatcher() {\n      return false;\n    }\n  });\n} // Lifted/adapted from\n//   https://github.com/facebook/react/blob/master/src/isomorphic/classic/types/ReactPropTypes.js\n\nvar ANONYMOUS = '<<anonymous>>';\n\nfunction PropTypeError(message) {\n  this.message = message;\n  this.stack = '';\n} // Make `instanceof Error` still work for returned errors.\n\n\nPropTypeError.prototype = Error.prototype;\nvar reactPropTypeLocationNames = {\n  prop: 'prop',\n  context: 'context',\n  childContext: 'child context'\n};\n\nfunction createChainableTypeChecker(validate) {\n  function checkType(isRequired, props, propName, componentName, location, propFullName) {\n    componentName = componentName || ANONYMOUS;\n    propFullName = propFullName || propName;\n\n    if (props[propName] == null) {\n      var locationName = reactPropTypeLocationNames[location];\n\n      if (isRequired) {\n        if (props[propName] === null) {\n          return new PropTypeError(\"The \" + locationName + \" `\" + propFullName + \"` is marked as required \" + (\"in `\" + componentName + \"`, but its value is `null`.\"));\n        }\n\n        return new PropTypeError(\"The \" + locationName + \" `\" + propFullName + \"` is marked as required in \" + (\"`\" + componentName + \"`, but its value is `undefined`.\"));\n      }\n\n      return null;\n    } else {\n      return validate(props, propName, componentName, location, propFullName);\n    }\n  }\n\n  var chainedCheckType = checkType.bind(null, false);\n  chainedCheckType.isRequired = checkType.bind(null, true);\n  return chainedCheckType;\n}\n\nexport function propType(doc) {\n  return createChainableTypeChecker(function (props, propName) {\n    var prop = props[propName];\n\n    try {\n      if (!prop.loading) {\n        check(doc, prop);\n      }\n\n      return null;\n    } catch (e) {\n      // Need a much better error.\n      // Also we aren't checking for extra fields\n      return e;\n    }\n  });\n}","map":null,"metadata":{},"sourceType":"module"}