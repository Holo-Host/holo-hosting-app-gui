{"ast":null,"code":"'use strict';\n\nvar _regenerator = require('babel-runtime/regenerator');\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');\n\nvar _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar ResponseBuilder = require('./response-builder');\n\nvar FetchMock = {};\n\nFetchMock.fetchHandler = function (url, opts) {\n  var _this = this;\n\n  var response = this.executeRouter(url, opts); // If the response says to throw an error, throw it\n  // It only makes sense to do this before doing any async stuff below\n  // as the async stuff swallows catastrophic errors in a promise\n  // Type checking is to deal with sinon spies having a throws property :-0\n\n  if (response.throws && typeof response !== 'function') {\n    throw response.throws;\n  } // this is used to power the .flush() method\n\n\n  var done = void 0;\n\n  this._holdingPromises.push(new this.config.Promise(function (res) {\n    return done = res;\n  })); // wrapped in this promise to make sure we respect custom Promise\n  // constructors defined by the user\n\n\n  return new this.config.Promise(function (res, rej) {\n    _this.generateResponse(response, url, opts).then(res, rej).then(done, done);\n  });\n};\n\nFetchMock.fetchHandler.isMock = true;\n\nFetchMock.executeRouter = function (url, opts) {\n  var response = this.router(url, opts);\n\n  if (response) {\n    return response;\n  }\n\n  if (this.config.warnOnFallback) {\n    console.warn('Unmatched ' + (opts && opts.method || 'GET') + ' to ' + url); // eslint-disable-line\n  }\n\n  this.push(null, [url, opts]);\n\n  if (this.fallbackResponse) {\n    return this.fallbackResponse;\n  }\n\n  if (!this.config.fallbackToNetwork) {\n    throw new Error('No fallback response defined for ' + (opts && opts.method || 'GET') + ' to ' + url);\n  }\n\n  return this.getNativeFetch();\n};\n\nFetchMock.generateResponse = function () {\n  var _ref = (0, _asyncToGenerator3.default)(\n  /*#__PURE__*/\n  _regenerator2.default.mark(function _callee(response, url, opts) {\n    return _regenerator2.default.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!(typeof response === 'function' || typeof response.then === 'function')) {\n              _context.next = 10;\n              break;\n            }\n\n            if (!(typeof response === 'function')) {\n              _context.next = 5;\n              break;\n            }\n\n            response = response(url, opts);\n            _context.next = 8;\n            break;\n\n          case 5:\n            _context.next = 7;\n            return response.then(function (it) {\n              return it;\n            });\n\n          case 7:\n            response = _context.sent;\n\n          case 8:\n            _context.next = 0;\n            break;\n\n          case 10:\n            if (!this.config.Response.prototype.isPrototypeOf(response)) {\n              _context.next = 12;\n              break;\n            }\n\n            return _context.abrupt('return', response);\n\n          case 12:\n            return _context.abrupt('return', new ResponseBuilder(url, response, this).exec());\n\n          case 13:\n          case 'end':\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  }));\n\n  return function (_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nFetchMock.router = function (url, opts) {\n  var route = this.routes.find(function (route) {\n    return route.matcher(url, opts);\n  });\n\n  if (route) {\n    this.push(route.name, [url, opts]);\n    return route.response;\n  }\n};\n\nFetchMock.getNativeFetch = function () {\n  var func = this.realFetch || this.isSandbox && this.config.fetch;\n\n  if (!func) {\n    throw new Error('Falling back to network only available on gloabl fetch-mock, or by setting config.fetch on sandboxed fetch-mock');\n  }\n\n  return func;\n};\n\nFetchMock.push = function (name, args) {\n  if (name) {\n    this._calls[name] = this._calls[name] || [];\n\n    this._calls[name].push(args);\n\n    this._allCalls.push(args);\n  } else {\n    args.unmatched = true;\n\n    this._allCalls.push(args);\n  }\n};\n\nmodule.exports = FetchMock;","map":null,"metadata":{},"sourceType":"script"}