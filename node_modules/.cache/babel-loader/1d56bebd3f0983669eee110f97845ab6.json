{"ast":null,"code":"'use strict';\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nvar _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');\n\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);\n\nvar _entries = require('babel-runtime/core-js/object/entries');\n\nvar _entries2 = _interopRequireDefault(_entries);\n\nvar _keys = require('babel-runtime/core-js/object/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar _glob = require('glob-to-regexp');\n\nvar _express = require('path-to-regexp');\n\nvar URL = require('url');\n\nvar querystring = require('querystring');\n\nfunction normalizeRequest(url, options, Request) {\n  if (Request.prototype.isPrototypeOf(url)) {\n    return {\n      url: url.url,\n      method: url.method,\n      headers: function () {\n        var headers = {};\n        url.headers.forEach(function (name) {\n          return headers[name] = url.headers.name;\n        });\n        return headers;\n      }()\n    };\n  } else {\n    return {\n      url: url,\n      method: options && options.method || 'GET',\n      headers: options && options.headers\n    };\n  }\n}\n\nvar stringMatchers = {\n  begin: function begin(targetString) {\n    return function (_ref) {\n      var url = _ref.url;\n      return url.indexOf(targetString) === 0;\n    };\n  },\n  end: function end(targetString) {\n    return function (_ref2) {\n      var url = _ref2.url;\n      return url.substr(-targetString.length) === targetString;\n    };\n  },\n  glob: function glob(targetString) {\n    var urlRX = _glob(targetString);\n\n    return function (_ref3) {\n      var url = _ref3.url;\n      return urlRX.test(url);\n    };\n  },\n  express: function express(targetString) {\n    var urlRX = _express(targetString);\n\n    return function (_ref4) {\n      var url = _ref4.url;\n      return urlRX.test(url);\n    };\n  }\n};\n\nvar headersToLowerCase = function headersToLowerCase(headers) {\n  return (0, _keys2.default)(headers).reduce(function (obj, k) {\n    obj[k.toLowerCase()] = headers[k];\n    return obj;\n  }, {});\n};\n\nfunction areHeadersEqual(actualHeader, expectedHeader) {\n  actualHeader = Array.isArray(actualHeader) ? actualHeader : [actualHeader];\n  expectedHeader = Array.isArray(expectedHeader) ? expectedHeader : [expectedHeader];\n\n  if (actualHeader.length !== expectedHeader.length) {\n    return false;\n  }\n\n  return actualHeader.every(function (val, i) {\n    return val === expectedHeader[i];\n  });\n}\n\nfunction getHeaderMatcher(_ref5, Headers) {\n  var expectedHeaders = _ref5.headers;\n\n  if (!expectedHeaders) {\n    return function () {\n      return true;\n    };\n  }\n\n  var expectation = headersToLowerCase(expectedHeaders);\n  return function (_ref6) {\n    var _ref6$headers = _ref6.headers,\n        headers = _ref6$headers === undefined ? {} : _ref6$headers;\n\n    if (headers instanceof Headers) {\n      // node-fetch 1 Headers\n      if (typeof headers.raw === 'function') {\n        headers = (0, _entries2.default)(headers.raw());\n      }\n\n      headers = [].concat((0, _toConsumableArray3.default)(headers)).reduce(function (map, _ref7) {\n        var _ref8 = (0, _slicedToArray3.default)(_ref7, 2),\n            key = _ref8[0],\n            val = _ref8[1];\n\n        map[key] = val;\n        return map;\n      }, {});\n    }\n\n    var lowerCaseHeaders = headersToLowerCase(headers);\n    return (0, _keys2.default)(expectation).every(function (headerName) {\n      return areHeadersEqual(lowerCaseHeaders[headerName], expectation[headerName]);\n    });\n  };\n}\n\nvar getMethodMatcher = function getMethodMatcher(route) {\n  return function (_ref9) {\n    var method = _ref9.method;\n    return !route.method || route.method === (method ? method.toLowerCase() : 'get');\n  };\n};\n\nvar getQueryStringMatcher = function getQueryStringMatcher(route) {\n  if (!route.query) {\n    return function () {\n      return true;\n    };\n  }\n\n  var keys = (0, _keys2.default)(route.query);\n  return function (_ref10) {\n    var url = _ref10.url;\n    var query = querystring.parse(URL.parse(url).query);\n    return keys.every(function (key) {\n      return query[key] === route.query[key];\n    });\n  };\n};\n\nvar getUrlMatcher = function getUrlMatcher(route) {\n  // When the matcher is a function it shodul not be compared with the url\n  // in the normal way\n  if (typeof route.matcher === 'function') {\n    return function () {\n      return true;\n    };\n  }\n\n  if (route.matcher instanceof RegExp) {\n    var urlRX = route.matcher;\n    return function (_ref11) {\n      var url = _ref11.url;\n      return urlRX.test(url);\n    };\n  }\n\n  if (route.matcher === '*') {\n    return function () {\n      return true;\n    };\n  }\n\n  if (route.matcher.indexOf('^') === 0) {\n    throw new Error('Using \\'^\\' to denote the start of a url is deprecated. Use \\'begin:\\' instead');\n  }\n\n  for (var shorthand in stringMatchers) {\n    if (route.matcher.indexOf(shorthand + ':') === 0) {\n      var url = route.matcher.replace(new RegExp('^' + shorthand + ':'), '');\n      return stringMatchers[shorthand](url);\n    }\n  } // if none of the special syntaxes apply, it's just a simple string match\n\n\n  var expectedUrl = route.matcher;\n  return function (_ref12) {\n    var url = _ref12.url;\n\n    if (route.query && expectedUrl.indexOf('?')) {\n      return url.indexOf(expectedUrl) === 0;\n    }\n\n    return url === expectedUrl;\n  };\n};\n\nvar sanitizeRoute = function sanitizeRoute(route) {\n  route = (0, _assign2.default)({}, route);\n\n  if (typeof route.response === 'undefined') {\n    throw new Error('Each route must define a response');\n  }\n\n  if (!route.matcher) {\n    throw new Error('Each route must specify a string, regex or function to match calls to fetch');\n  }\n\n  if (!route.name) {\n    route.name = route.matcher.toString();\n    route.__unnamed = true;\n  }\n\n  if (route.method) {\n    route.method = route.method.toLowerCase();\n  }\n\n  return route;\n};\n\nvar getFunctionMatcher = function getFunctionMatcher(route) {\n  if (typeof route.matcher === 'function') {\n    var matcher = route.matcher;\n    return function (req, _ref13) {\n      var _ref14 = (0, _slicedToArray3.default)(_ref13, 2),\n          url = _ref14[0],\n          options = _ref14[1];\n\n      return matcher(url, options);\n    };\n  } else {\n    return function () {\n      return true;\n    };\n  }\n};\n\nvar generateMatcher = function generateMatcher(route, config) {\n  var matchers = [getQueryStringMatcher(route), getMethodMatcher(route), getHeaderMatcher(route, config.Headers), getUrlMatcher(route), getFunctionMatcher(route)];\n  return function (url, options) {\n    var req = normalizeRequest(url, options, config.Request);\n    return matchers.every(function (matcher) {\n      return matcher(req, [url, options]);\n    });\n  };\n};\n\nvar limitMatcher = function limitMatcher(route) {\n  if (!route.repeat) {\n    return;\n  }\n\n  var matcher = route.matcher;\n  var timesLeft = route.repeat;\n\n  route.matcher = function (url, options) {\n    var match = timesLeft && matcher(url, options);\n\n    if (match) {\n      timesLeft--;\n      return true;\n    }\n  };\n\n  route.reset = function () {\n    return timesLeft = route.repeat;\n  };\n};\n\nmodule.exports = function (route) {\n  route = sanitizeRoute(route);\n  route.matcher = generateMatcher(route, this.config);\n  limitMatcher(route);\n  return route;\n};","map":null,"metadata":{},"sourceType":"script"}