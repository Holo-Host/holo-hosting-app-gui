{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n\n    for (var p in s) {\n      if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n  }\n\n  return t;\n};\n\nimport { print } from 'graphql/language/printer';\nimport { assign, createFragmentMap, getDefaultValues, getFragmentDefinitions, getOperationDefinition, isField, isIdValue, isInlineFragment, isProduction, resultKeyNameFromField, shouldInclude, storeKeyNameFromField, getQueryDefinition, toIdValue } from 'apollo-utilities';\nimport { defaultNormalizedCacheFactory, ObjectCache } from './objectCache';\n\nvar WriteError =\n/** @class */\nfunction (_super) {\n  __extends(WriteError, _super);\n\n  function WriteError() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = 'WriteError';\n    return _this;\n  }\n\n  return WriteError;\n}(Error);\n\nexport { WriteError };\nexport function enhanceErrorWithDocument(error, document) {\n  // XXX A bit hacky maybe ...\n  var enhancedError = new WriteError(\"Error writing result to store for query:\\n \" + print(document));\n  enhancedError.message += '\\n' + error.message;\n  enhancedError.stack = error.stack;\n  return enhancedError;\n}\n/**\n * Writes the result of a query to the store.\n *\n * @param result The result object returned for the query document.\n *\n * @param query The query document whose result we are writing to the store.\n *\n * @param store The {@link NormalizedCache} used by Apollo for the `data` portion of the store.\n *\n * @param variables A map from the name of a variable to its value. These variables can be\n * referenced by the query document.\n *\n * @param dataIdFromObject A function that returns an object identifier given a particular result\n * object. See the store documentation for details and an example of this function.\n *\n * @param fragmentMap A map from the name of a fragment to its fragment definition. These fragments\n * can be referenced within the query document.\n *\n * @param fragmentMatcherFunction A function to use for matching fragment conditions in GraphQL documents\n */\n\nexport function writeQueryToStore(_a) {\n  var result = _a.result,\n      query = _a.query,\n      _b = _a.storeFactory,\n      storeFactory = _b === void 0 ? defaultNormalizedCacheFactory : _b,\n      _c = _a.store,\n      store = _c === void 0 ? storeFactory() : _c,\n      variables = _a.variables,\n      dataIdFromObject = _a.dataIdFromObject,\n      _d = _a.fragmentMap,\n      fragmentMap = _d === void 0 ? {} : _d,\n      fragmentMatcherFunction = _a.fragmentMatcherFunction;\n  var queryDefinition = getQueryDefinition(query);\n  variables = assign({}, getDefaultValues(queryDefinition), variables);\n\n  try {\n    return writeSelectionSetToStore({\n      dataId: 'ROOT_QUERY',\n      result: result,\n      selectionSet: queryDefinition.selectionSet,\n      context: {\n        store: store,\n        storeFactory: storeFactory,\n        processedData: {},\n        variables: variables,\n        dataIdFromObject: dataIdFromObject,\n        fragmentMap: fragmentMap,\n        fragmentMatcherFunction: fragmentMatcherFunction\n      }\n    });\n  } catch (e) {\n    throw enhanceErrorWithDocument(e, query);\n  }\n}\nexport function writeResultToStore(_a) {\n  var dataId = _a.dataId,\n      result = _a.result,\n      document = _a.document,\n      _b = _a.storeFactory,\n      storeFactory = _b === void 0 ? defaultNormalizedCacheFactory : _b,\n      _c = _a.store,\n      store = _c === void 0 ? storeFactory() : _c,\n      variables = _a.variables,\n      dataIdFromObject = _a.dataIdFromObject,\n      fragmentMatcherFunction = _a.fragmentMatcherFunction; // XXX TODO REFACTOR: this is a temporary workaround until query normalization is made to work with documents.\n\n  var operationDefinition = getOperationDefinition(document);\n  var selectionSet = operationDefinition.selectionSet;\n  var fragmentMap = createFragmentMap(getFragmentDefinitions(document));\n  variables = assign({}, getDefaultValues(operationDefinition), variables);\n\n  try {\n    return writeSelectionSetToStore({\n      result: result,\n      dataId: dataId,\n      selectionSet: selectionSet,\n      context: {\n        store: store,\n        storeFactory: storeFactory,\n        processedData: {},\n        variables: variables,\n        dataIdFromObject: dataIdFromObject,\n        fragmentMap: fragmentMap,\n        fragmentMatcherFunction: fragmentMatcherFunction\n      }\n    });\n  } catch (e) {\n    throw enhanceErrorWithDocument(e, document);\n  }\n}\nexport function writeSelectionSetToStore(_a) {\n  var result = _a.result,\n      dataId = _a.dataId,\n      selectionSet = _a.selectionSet,\n      context = _a.context;\n  var variables = context.variables,\n      store = context.store,\n      fragmentMap = context.fragmentMap;\n  selectionSet.selections.forEach(function (selection) {\n    var included = shouldInclude(selection, variables);\n\n    if (isField(selection)) {\n      var resultFieldKey = resultKeyNameFromField(selection);\n      var value = result[resultFieldKey];\n\n      if (included) {\n        if (typeof value !== 'undefined') {\n          writeFieldToStore({\n            dataId: dataId,\n            value: value,\n            field: selection,\n            context: context\n          });\n        } else {\n          // if this is a defered field we don't need to throw / warn\n          var isDefered = selection.directives && selection.directives.length && selection.directives.some(function (directive) {\n            return directive.name && directive.name.value === 'defer';\n          });\n\n          if (!isDefered && context.fragmentMatcherFunction) {\n            // XXX We'd like to throw an error, but for backwards compatibility's sake\n            // we just print a warning for the time being.\n            //throw new WriteError(`Missing field ${resultFieldKey} in ${JSON.stringify(result, null, 2).substring(0, 100)}`);\n            if (!isProduction()) {\n              console.warn(\"Missing field \" + resultFieldKey + \" in \" + JSON.stringify(result, null, 2).substring(0, 100));\n            }\n          }\n        }\n      }\n    } else {\n      // This is not a field, so it must be a fragment, either inline or named\n      var fragment = void 0;\n\n      if (isInlineFragment(selection)) {\n        fragment = selection;\n      } else {\n        // Named fragment\n        fragment = (fragmentMap || {})[selection.name.value];\n\n        if (!fragment) {\n          throw new Error(\"No fragment named \" + selection.name.value + \".\");\n        }\n      }\n\n      var matches = true;\n\n      if (context.fragmentMatcherFunction && fragment.typeCondition) {\n        // TODO we need to rewrite the fragment matchers for this to work properly and efficiently\n        // Right now we have to pretend that we're passing in an idValue and that there's a store\n        // on the context.\n        var idValue = toIdValue({\n          id: 'self',\n          typename: undefined\n        });\n        var fakeContext = {\n          // NOTE: fakeContext always uses ObjectCache\n          // since this is only to ensure the return value of 'matches'\n          store: new ObjectCache({\n            self: result\n          }),\n          returnPartialData: false,\n          hasMissingField: false,\n          cacheRedirects: {}\n        };\n        matches = context.fragmentMatcherFunction(idValue, fragment.typeCondition.name.value, fakeContext);\n\n        if (!isProduction() && fakeContext.returnPartialData) {\n          console.error('WARNING: heuristic fragment matching going on!');\n        }\n      }\n\n      if (included && matches) {\n        writeSelectionSetToStore({\n          result: result,\n          selectionSet: fragment.selectionSet,\n          dataId: dataId,\n          context: context\n        });\n      }\n    }\n  });\n  return store;\n} // Checks if the id given is an id that was generated by Apollo\n// rather than by dataIdFromObject.\n\nfunction isGeneratedId(id) {\n  return id[0] === '$';\n}\n\nfunction mergeWithGenerated(generatedKey, realKey, cache) {\n  var generated = cache.get(generatedKey);\n  var real = cache.get(realKey);\n  Object.keys(generated).forEach(function (key) {\n    var value = generated[key];\n    var realValue = real[key];\n\n    if (isIdValue(value) && isGeneratedId(value.id) && isIdValue(realValue)) {\n      mergeWithGenerated(value.id, realValue.id, cache);\n    }\n\n    cache.delete(generatedKey);\n    cache.set(realKey, __assign({}, generated, real));\n  });\n}\n\nfunction isDataProcessed(dataId, field, processedData) {\n  if (!processedData) {\n    return false;\n  }\n\n  if (processedData[dataId]) {\n    if (processedData[dataId].indexOf(field) >= 0) {\n      return true;\n    } else {\n      processedData[dataId].push(field);\n    }\n  } else {\n    processedData[dataId] = [field];\n  }\n\n  return false;\n}\n\nfunction writeFieldToStore(_a) {\n  var field = _a.field,\n      value = _a.value,\n      dataId = _a.dataId,\n      context = _a.context;\n  var variables = context.variables,\n      dataIdFromObject = context.dataIdFromObject,\n      store = context.store;\n  var storeValue;\n  var storeObject;\n  var storeFieldName = storeKeyNameFromField(field, variables); // specifies if we need to merge existing keys in the store\n\n  var shouldMerge = false; // If we merge, this will be the generatedKey\n\n  var generatedKey = ''; // If this is a scalar value...\n\n  if (!field.selectionSet || value === null) {\n    storeValue = value != null && typeof value === 'object' ? // If the scalar value is a JSON blob, we have to \"escape\" it so it can’t pretend to be\n    // an id.\n    {\n      type: 'json',\n      json: value\n    } : // Otherwise, just store the scalar directly in the store.\n    value;\n  } else if (Array.isArray(value)) {\n    var generatedId = dataId + \".\" + storeFieldName;\n    storeValue = processArrayValue(value, generatedId, field.selectionSet, context);\n  } else {\n    // It's an object\n    var valueDataId = dataId + \".\" + storeFieldName;\n    var generated = true; // We only prepend the '$' if the valueDataId isn't already a generated\n    // id.\n\n    if (!isGeneratedId(valueDataId)) {\n      valueDataId = '$' + valueDataId;\n    }\n\n    if (dataIdFromObject) {\n      var semanticId = dataIdFromObject(value); // We throw an error if the first character of the id is '$. This is\n      // because we use that character to designate an Apollo-generated id\n      // and we use the distinction between user-desiginated and application-provided\n      // ids when managing overwrites.\n\n      if (semanticId && isGeneratedId(semanticId)) {\n        throw new Error('IDs returned by dataIdFromObject cannot begin with the \"$\" character.');\n      }\n\n      if (semanticId) {\n        valueDataId = semanticId;\n        generated = false;\n      }\n    }\n\n    if (!isDataProcessed(valueDataId, field, context.processedData)) {\n      writeSelectionSetToStore({\n        dataId: valueDataId,\n        result: value,\n        selectionSet: field.selectionSet,\n        context: context\n      });\n    } // We take the id and escape it (i.e. wrap it with an enclosing object).\n    // This allows us to distinguish IDs from normal scalars.\n\n\n    var typename = value.__typename;\n    storeValue = toIdValue({\n      id: valueDataId,\n      typename: typename\n    }, generated); // check if there was a generated id at the location where we're\n    // about to place this new id. If there was, we have to merge the\n    // data from that id with the data we're about to write in the store.\n\n    storeObject = store.get(dataId);\n    var escapedId = storeObject && storeObject[storeFieldName];\n\n    if (escapedId !== storeValue && isIdValue(escapedId)) {\n      var hadTypename = escapedId.typename !== undefined;\n      var hasTypename = typename !== undefined;\n      var typenameChanged = hadTypename && hasTypename && escapedId.typename !== typename; // If there is already a real id in the store and the current id we\n      // are dealing with is generated, we throw an error.\n      // One exception we allow is when the typename has changed, which occurs\n      // when schema defines a union, both with and without an ID in the same place.\n      // checks if we \"lost\" the read id\n\n      if (generated && !escapedId.generated && !typenameChanged) {\n        throw new Error(\"Store error: the application attempted to write an object with no provided id\" + (\" but the store already contains an id of \" + escapedId.id + \" for this object. The selectionSet\") + \" that was trying to be written is:\\n\" + print(field));\n      } // checks if we \"lost\" the typename\n\n\n      if (hadTypename && !hasTypename) {\n        throw new Error(\"Store error: the application attempted to write an object with no provided typename\" + (\" but the store already contains an object with typename of \" + escapedId.typename + \" for the object of id \" + escapedId.id + \". The selectionSet\") + \" that was trying to be written is:\\n\" + print(field));\n      }\n\n      if (escapedId.generated) {\n        generatedKey = escapedId.id; // We should only merge if it's an object of the same type,\n        // otherwise we should delete the generated object\n\n        if (typenameChanged) {\n          // Only delete the generated object when the old object was\n          // inlined, and the new object is not. This is indicated by\n          // the old id being generated, and the new id being real.\n          if (!generated) {\n            store.delete(generatedKey);\n          }\n        } else {\n          shouldMerge = true;\n        }\n      }\n    }\n  }\n\n  var newStoreObj = __assign({}, store.get(dataId), (_b = {}, _b[storeFieldName] = storeValue, _b));\n\n  if (shouldMerge) {\n    mergeWithGenerated(generatedKey, storeValue.id, store);\n  }\n\n  storeObject = store.get(dataId);\n\n  if (!storeObject || storeValue !== storeObject[storeFieldName]) {\n    store.set(dataId, newStoreObj);\n  }\n\n  var _b;\n}\n\nfunction processArrayValue(value, generatedId, selectionSet, context) {\n  return value.map(function (item, index) {\n    if (item === null) {\n      return null;\n    }\n\n    var itemDataId = generatedId + \".\" + index;\n\n    if (Array.isArray(item)) {\n      return processArrayValue(item, itemDataId, selectionSet, context);\n    }\n\n    var generated = true;\n\n    if (context.dataIdFromObject) {\n      var semanticId = context.dataIdFromObject(item);\n\n      if (semanticId) {\n        itemDataId = semanticId;\n        generated = false;\n      }\n    }\n\n    if (!isDataProcessed(itemDataId, selectionSet, context.processedData)) {\n      writeSelectionSetToStore({\n        dataId: itemDataId,\n        result: item,\n        selectionSet: selectionSet,\n        context: context\n      });\n    }\n\n    return toIdValue({\n      id: itemDataId,\n      typename: item.__typename\n    }, generated);\n  });\n}","map":null,"metadata":{},"sourceType":"module"}