{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nexports.is = is;\nexports.isType = isType;\nexports.validate = validate;\nexports.shallowEqual = shallowEqual;\n\nrequire('./definitions/init');\n\nvar _require = require('./definitions'),\n    ALIAS_KEYS = _require.ALIAS_KEYS,\n    NODE_FIELDS = _require.NODE_FIELDS,\n    BUILDER_KEYS = _require.BUILDER_KEYS;\n\nvar t = exports; // Maps all exports to t\n\n/**\n * Registers `is[Type]` and `assert[Type]` generated functions for a given `type`.\n * Pass `skipAliasCheck` to force it to directly compare `node.type` with `type`.\n */\n\nfunction registerType(type) {\n  var key = 'is' + type;\n\n  var _isType = t[key] !== undefined ? t[key] : t[key] = function (node, opts) {\n    return t.is(type, node, opts);\n  };\n\n  t['assert' + type] = function (node) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!_isType(node, opts)) {\n      throw new Error('Expected type \"' + type + '\" with option ' + JSON.stringify(opts));\n    }\n  };\n}\n\nexports.ALIAS_KEYS = ALIAS_KEYS;\nexports.NODE_FIELDS = NODE_FIELDS;\nexports.BUILDER_KEYS = BUILDER_KEYS;\n/**\n * Registers `is[Type]` and `assert[Type]` for all types.\n */\n\nfor (var type in t.NODE_FIELDS) {\n  registerType(type);\n}\n/**\n * Flip `ALIAS_KEYS` for faster access in the reverse direction.\n */\n\n\nvar TYPES = exports.TYPES = [];\nt.FLIPPED_ALIAS_KEYS = Object.keys(t.ALIAS_KEYS).reduce(function (acc, type) {\n  var aliasKeys = t.ALIAS_KEYS[type];\n  aliasKeys.forEach(function (alias) {\n    if (acc[alias] === undefined) {\n      TYPES.push(alias); // Populate `TYPES` with FLIPPED_ALIAS_KEY(S)\n      // Registers `is[Alias]` and `assert[Alias]` functions for all aliases.\n\n      t[alias.toUpperCase() + '_TYPES'] = acc[alias];\n      registerType(alias);\n      acc[alias] = [];\n    }\n\n    acc[alias].push(type);\n  });\n  return acc;\n}, {});\n/**\n * Returns whether `node` is of given `type`.\n *\n * For better performance, use this instead of `is[Type]` when `type` is unknown.\n * Optionally, pass `skipAliasCheck` to directly compare `node.type` with `type`.\n */\n\nfunction is(type, node, opts) {\n  if (node === null || (typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object') {\n    return false;\n  }\n\n  var matches = isType(node.kind, type);\n\n  if (!matches) {\n    return false;\n  }\n\n  if (typeof opts === 'undefined') {\n    return true;\n  } else {\n    return t.shallowEqual(node, opts);\n  }\n}\n/**\n * Test if a `nodeType` is a `targetType` or if `targetType` is an alias of `nodeType`.\n */\n\n\nfunction isType(nodeType, targetType) {\n  if (nodeType === targetType) {\n    return true;\n  } // This is a fast-path. If the test above failed, but an alias key is found, then the\n  // targetType was a primary node type, so there's no need to check the aliases.\n\n\n  if (t.ALIAS_KEYS[targetType]) {\n    return false;\n  }\n\n  var aliases = t.FLIPPED_ALIAS_KEYS[targetType];\n\n  if (aliases) {\n    if (aliases[0] === nodeType) {\n      return true;\n    }\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = aliases[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var alias = _step.value;\n\n        if (nodeType === alias) {\n          return true;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n/**\n * For each call of #defineType, the following expression evalutates and generates\n * a builder function that validates incoming arguments and returns a valid AST node.\n */\n\n\nvar _loop = function _loop(_type) {\n  var keys = t.BUILDER_KEYS[_type];\n  var fields = t.NODE_FIELDS[_type];\n\n  function builder() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (args.length > keys.length) {\n      throw new Error('t.' + _type + ': Too many arguments passed. Received ' + args.length + ' but can receive ' + ('no more than ' + keys.length));\n    }\n\n    var node = keys.reduce(function (node, key, i) {\n      node[key] = args[i] === undefined ? fields[key].default : args[i];\n      return node;\n    }, {\n      kind: _type\n    });\n\n    for (var key in node) {\n      validate(node, key, node[key]);\n    }\n\n    return node;\n  }\n\n  t[_type[0].toLowerCase() + _type.slice(1)] = builder;\n};\n\nfor (var _type in t.BUILDER_KEYS) {\n  _loop(_type);\n}\n/**\n * Executes the field validators for a given node\n */\n\n\nfunction validate(node, key, val) {\n  if (node === null || (typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object') {\n    return;\n  }\n\n  var fields = t.NODE_FIELDS[node.kind];\n\n  if (fields === undefined) {\n    return;\n  }\n\n  var field = fields[key];\n\n  if (field === undefined || field.validate === undefined) {\n    return;\n  }\n\n  if (field.optional && (val === undefined || val === null)) {\n    return;\n  }\n\n  field.validate(node, key, val);\n}\n/**\n * Test if an object is shallowly equal.\n */\n\n\nfunction shallowEqual(actual, expected) {\n  for (var key in expected) {\n    if (expected.hasOwnProperty(key) && actual[key] !== expected[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}","map":null,"metadata":{},"sourceType":"script"}